**Important warning**
Some commands of `QSoas` may not be documented here. It means they are
supported in no way: their syntax may change without notice, they may
disappear, they may turn out to do completely different things in the
end. In short, **use them at your own risks** (and it would be a good
idea to check out the code, in that case).


# Commands, arguments and options (how to read this document)

QSoas works by entering commands inside the command prompt.

Most commands have arguments and options. Arguments and options are
separated by spaces:

~~~ 
QSoas> command argument1 argument2 "argument 3" /option=option /option2="with spaces"
~~~

If you need to pass arguments or option values that have spaces, make
sure you quote them using `"` or `'`, like in the above example.

Arguments are indicated like _that_ in the documentation below. You
need to provide all the arguments for a command to work. Some
arguments are followed by _..._, which means that you can pass several
space-separated arguments. This is the case for [cmd: load],
for instance:

~~~
QSoas> load file1 file2 file3
~~~

Some options are marked as "(default)", which means that, if all
arguments of the command are already specified, you can omit the
`/option=` part of the option. For instance, to set the
[cmd: temperature] to 300 K, you should be doing that:

~~~
QSoas> temperature /set=300
~~~

But, as `/set` is the default option, you can omit the `/set=`
altogether and write:

~~~
QSoas> temperature 300
~~~

In this documentation, all options and arguments have mouseover texts
that give a short explanation of what kind of values are expected.

Some commands are marked as *(interactive)*. This means that their use
requires user interaction, which in particular makes them unsuitable
for using inside [scripts](#scripting).

## Note about text files

Many commands of QSoas make use of "plain text files", i.e. files that
simply contain unformatted text. These are for instance:

 * files for defining fits with [cmd: load-fits]
 * scripts to be run with [cmd: run]
 * definitions of kinetic systems for
  [cmd: fit-kinetic-system]
 * even saved fit parameters are plain text files

On windows, use Notepad to edit them. On Linux, `pico`, `nano`, `vi`
or `emacs` are pretty good choices. On MacOS, TextEdit, but make sure
you hit Cmd+Shift+T to switch to "plain text" format (the default is
rich text in the RTF format, and `QSoas` does not understand RTF).


## Buffer list arguments {#buffer-lists}

Many commands, such as [cmd: flag], [cmd: contract] and so on take
lists of buffers (or datasets) as arguments. This list can take
several forms:

 * A comma-separated of buffer numbers (the ones given by 
   [cmd: show-stack]), such as: `1,4,7` (0 is the current buffer, 1,
   the one just before, which you can reach using [cmd: undo], etc.).
 * A number range, such as `1..7`, meaning all buffers from 1 to 7
   included.
 * A number range with a step, such as `1..7:3`, meaning `1,4,7`.
 * `all` for all buffers on the stack.
 * `displayed` for the currently displayed buffers.

It is also possible to make use of buffer flags set by [cmd: flag]:

 * `flagged` stands for all flagged buffers (regardless of the name of
   the flag);
 * `unflagged` for all buffers that don't have a flag;
 * `flagged-` and `unflagged-` do the same, but with the buffers in
   the reverse order;
 * `flagged:`_flagname_ for all buffers that have the flag _flagname_;
 * `unflagged:`_flagname_ for all buffers that don't have the flag
   _flagname_;
 * and the variants `flagged-:`_flagname_ and `unflagged-:`_flagname_
   for the reversed order.

## Buffer columns {#column-names}

Some commands such as [cmd: bin] take as arguments or options buffer
column names. There are three way to designate those:

 * using a number: `1` is the $$x$$ column, `2` is the $$y$$ column,
   and so on
 * using a number prefixed by `#`: this is a 0-based index, `#0` is
   then the $$x$$ column
 * by its name: `x`, `y`, `z`, `y2`, `y3` and so on. `y2` is
   equivalent to `z`

Some commands (like [cmd: contract]) take column lists, which are
comma-separated lists of columns (just like above), with the addition
of range: `2..6` are columns 2 to 6 inclusive.

# General

Here are the commands to interact with QSoas in the most general way:
exit, change directory, change various global parameters.


{::comment} synopsis-start: quit {:/}

### quit - Quit {#cmd-quit}

`quit` 

Alias: `q`


{::comment} synopsis-end: quit {:/}
{::comment} description-start: quit {:/}
Exits QSoas, losing all the current session. Keep in mind, though,
that the full log of the session is always available in the
`soas.log` file created in the initial directory, which is indicated in
the very beginning in the terminal.
{::comment} description-end: quit {:/}


{::comment} synopsis-start: credits {:/}

### credits - Credits {#cmd-credits}

`credits` 


{::comment} synopsis-end: credits {:/}
{::comment} description-start: credits {:/}

This command displays credits, copyright and license information of 
QSoas and all the dependencies linked to or built in your version.

It also lists publications whose findings/equations/algorithms were
directly used in QSoas.
{::comment} description-end: credits {:/}


{::comment} synopsis-start: save-history {:/}

### save-history - Save history {#cmd-save-history}

`save-history` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Output file

{::comment} synopsis-end: save-history {:/}
{::comment} description-start: save-history {:/}
Saves all the commands contained in the history, that is all the
commands that were launched from the beginning of the session, to the
given (text) file.

This can be used for saving a series of command that should be applied
repetitively as a [script](#scripting).
{::comment} description-end: save-history {:/}

{::comment} synopsis-start: cd {:/}

### cd - Change directory {#cmd-cd}

`cd` _directory_{:title="Path of a file (or a directory)"} `/from-home=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/from-script=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `G`

  * _directory_{:title="Path of a file (or a directory)"}: New directory
  * `/from-home=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, relative from the home directory
  * `/from-script=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, cd relative from the current script directory

{::comment} synopsis-end: cd {:/}
{::comment} description-start: cd {:/}
Changes the current working directory. If `/from-home` is specified,
the directory is assumed to be relative to the user's home directory. 
If `/from-script` is specified, the directory is assumed to be
relative to that of the command file currently being executed by a 
[cmd: run] command (or in a [startup script](#cmd-startup-files)).



As of now, it doesn't change the output files and the log files, but
it eventually will.
{::comment} description-end: cd {:/}
{::comment} synopsis-start: pwd {:/}

### pwd - Working directory {#cmd-pwd}

`pwd` 


{::comment} synopsis-end: pwd {:/}
{::comment} description-start: pwd {:/}
Prints the full path of the current directory.

It is also the one indicated in the title of the QSoas window.
{::comment} description-end: pwd {:/}

{::comment} synopsis-start: temperature {:/}

### temperature - Temperature {#cmd-temperature}

`temperature` `/set=`_number_{:title="A floating-point number"}

Alias: `T`

  * `/set=`_number_{:title="A floating-point number"} (default): Sets the temperature

{::comment} synopsis-end: temperature {:/}
{::comment} description-start: temperature {:/}
Shows or sets the current temperature. The temperature is used in many
places, mostly in fits to serve as the initial value for the
temperature parameter. To set the temperature, pass its new value as
the `/set` option (the `/set=` part is optional):

~~~
QSoas> temperature 310
~~~

{::comment} description-end: temperature {:/}

{::comment} synopsis-start: commands {:/}

### commands - Commands {#cmd-commands}

`commands` 


{::comment} synopsis-end: commands {:/}
{::comment} description-start: commands {:/}
List all available commands, with a short help text. This also
includes used-defined commands, such as custom fits loaded from a fit file.
{::comment} description-end: commands {:/}
{::comment} synopsis-start: help {:/}

### help - Help on... {#cmd-help}

`help` _command_{:title="The name of one of QSoas's commands"} `/online=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `?`

  * _command_{:title="The name of one of QSoas's commands"}: The command on which to give help
  * `/online=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} (default): Show the online documentation in a browser

{::comment} synopsis-end: help {:/}
{::comment} description-start: help {:/}
Gives all help available on the given command. By default, it fires up
a browser to show the online help, unless you use `/online=false`.
{::comment} description-end: help {:/}

{::comment} synopsis-start: save-output {:/}

### save-output - Save output {#cmd-save-output}

`save-output` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Output file

{::comment} synopsis-end: save-output {:/}
{::comment} description-start: save-output {:/}
Save all text in the terminal to a plain text file.

Equivalent to copy-pasting the contents of the terminal to a plain
text file using a text editor.
{::comment} description-end: save-output {:/}


{::comment} synopsis-start: print {:/}

### print - Print {#cmd-print}

`print` `/file=`_file_{:title="Path of a file (or a directory)"} `/title=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `p`

  * `/file=`_file_{:title="Path of a file (or a directory)"}: Save as file
  * `/title=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Sets the title of the page as printed

{::comment} synopsis-end: print {:/}
{::comment} description-start: print {:/}
Prints the current view, providing a usual print dialog. If you just
want a PDF or PostScript file, just provide the file name as the
`/file` option.

An optional title can be added using the `/title` option.

**Important note** please keep in mind that QSoas is not designed to
be a data plotting system, it is a data analysis system. So plotting
capacities don't go far...
{::comment} description-end: print {:/}


{::comment} synopsis-start: define-alias {:/}

### define-alias - Define alias {#cmd-define-alias}

`define-alias` _alias_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _command_{:title="The name of one of QSoas's commands"} `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _alias_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The name to give to the new alias
  * _command_{:title="The name of one of QSoas's commands"}: The command to give an alias for
  * `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): All options

{::comment} synopsis-end: define-alias {:/}
{::comment} description-start: define-alias {:/}
The `define-alias` commands allows one to defined a shortcut for a
command one uses often with the same options. For instance, running:

~~~~
QSoas> define-alias fit-2exp fit-exponential-decay /exponentials=2 /loss=true
~~~~

creates a `fit-2exp` command that is equivalent to starting 
[cmd: fit-exponential-decay] with two
exponentials by default and film loss on. 

While it is possible to define "default options" for aliased commands
this way, there is no way to add arguments: you must still go on
specifying all the arguments to the alias.
{::comment} description-end: define-alias {:/}

{::comment} synopsis-start: display-aliases {:/}

### display-aliases - Display aliases {#cmd-display-aliases}

`display-aliases` 


{::comment} synopsis-end: display-aliases {:/}
{::comment} description-start: display-aliases {:/}
Shows a list of all the currently defined aliases.
{::comment} description-end: display-aliases {:/}

{::comment} synopsis-start: graphics-settings {:/}

### graphics-settings - Graphics settings {#cmd-graphics-settings}

`graphics-settings` `/line-width=`_number_{:title="A floating-point number"} `/opengl=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/antialias=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/line-width=`_number_{:title="A floating-point number"}: Sets the base line width for all lines/curves
  * `/opengl=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turns on/off the use of OpenGL acceleration
  * `/antialias=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turns on/off the use of antialised graphics

{::comment} synopsis-end: graphics-settings {:/}
{::comment} description-start: graphics-settings {:/}
Gives the possibility to tweak a few settings concerning display.

The settings are persistent and kept from one QSoas session until the
next one.

Turning on antialias will make QSoas use antialiased drawings, which
looks admittedly nicer, but requires much more computational
time. Printing or exporting to PDF files through [cmd: print]
always produces antialiased graphics, regardless of this option.

If you experience performance problems for displaying curves, use
`/opengl=true`, as this will instruct QSoas to use hardware
acceleration to display curves, which should greatly enhance the
display speed. It is off by default as some setups do not really
benefit from that.
{::comment} description-end: graphics-settings {:/}


{::comment} synopsis-start: ruby-run {:/}

### ruby-run - Ruby load {#cmd-ruby-run}

`ruby-run` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Ruby file to load

{::comment} synopsis-end: ruby-run {:/}
{::comment} description-start: ruby-run {:/}
This command loads and executes a Ruby file. For the time being, the
main interest of this command is to define complex functions in a
separate file. 

Imagine you have a file `function.rb` containing the text:

~~~~
def function(x,a)
  return x**(a**x)
end
~~~~

After running 

~~~~
QSoas> ruby-run function.rb
~~~~

You can use `function` like any normal function for fitting:

~~~~
QSoas> fit-arb 'function(x,a)'
~~~~
{::comment} description-end: ruby-run {:/}

{::comment} synopsis-start: break {:/}

### break - Break {#cmd-break}

`break` 


{::comment} synopsis-end: break {:/}
{::comment} description-start: break {:/}
Exits from the current script. 

Has no effect if not within a script.
{::comment} description-end: break {:/}



## Output file manipulation

Several commands (e.g.  various data analysis commands and the fit
commands) write data to the output file.

By default, the first time the output file is used, a `output.dat`
file is created in the current directory. Another file can be used by
providing its name to the [cmd: output] command.

{::comment} synopsis-start: output {:/}

### output - Change output file {#cmd-output}

`output` _file_{:title="Path of a file (or a directory)"} `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _file_{:title="Path of a file (or a directory)"}: Name of the new output file
  * `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, overwrite the file instead of appending

{::comment} synopsis-end: output {:/}
{::comment} description-start: output {:/}
Opens _file_ as the new output file. By default, if the file exists,
new data are appended, and the old data are left untouched. You can
force overwriting by specifiying `/truncate=true`.
{::comment} description-end: output {:/}

{::comment} synopsis-start: comment {:/}

### comment - Write line to output {#cmd-comment}

`comment` _comment_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _comment_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Comment line added to output file

{::comment} synopsis-end: comment {:/}
{::comment} description-start: comment {:/}
Writes the given line _comment_ to the output file.
{::comment} description-end: comment {:/}




# Data loading/saving

The main command for loading data is [cmd: load]

{::comment} synopsis-start: load {:/}

### load - Load {#cmd-load}

`load` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_ `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `l`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers
  * `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, ignores what is in the cache
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines

{::comment} synopsis-end: load {:/}
{::comment} description-start: load {:/}

Loads the given files and push them onto the data stack. QSoas
features several backends for loading files (``backends'' are roughly
equivalent to ``file formats''). In principle, QSoas is
smart enough to figure out which one is the correct one, but you can
force a given backend by using the appropriate `load-as-`
command. Using a backend directly also provides more control on the
way files are loaded (this can also be done via the numerous options
to `load`, which are forwarded to the appropriate backend). Currently
available backends:

 * [`text`](#cmd-load-as-text) for plain space-separated text
 * [`csv`](#cmd-load-as-csv) for CSV data

Look in their documentation for more information. QSoas tells you
which backend it used for loading a given file:

~~~~
QSoas> load 03.dat
Loading file: './03.dat' using backend text
~~~~

The command `load` caches the loaded file. If for some reason, the
cache gets in the way, use the direct `load-as-` commands, or
alternatively use `/ignore-cache=true`.

`load`, together with all the other commands that take several files
as arguments understand unix-like wildcards:

~~~~
QSoas> load *.dat
~~~~

This command loads all the `.dat` files from the current directory.

~~~~
QSoas> load [0-4]*.dat
~~~~

This loads only those that start with a digit from 0 to 4, etc.

The `load` command and the corresponding `load-as-` command makes it
possible to set dataset options just as with the 
[cmd: dataset-options].

The style option sets the color style when loading several curves:

~~~~
QSoas> load *.dat /style=red-blue
~~~~

This loads all the `.dat` files in the current directory, and displays
them with a color gradient from red (for the first loaded file) to
blue (for the last loaded file). This makes it very easy to follow
subtle modifications from one data file to the next.

The `/flags=` option makes it possible to flag buffers as they get
loaded. It has the same effect as running [cmd: flag] with the same
option on loaded datasets.


{::comment} description-end: load {:/}


{::comment} synopsis-start: load-as-text {:/}

### load-as-text - Load files with backend 'text' {#cmd-load-as-text}

`load-as-text` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_ `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers

{::comment} synopsis-end: load-as-text {:/}
{::comment} description-start: load-as-text {:/}

Load any number of files using the backend `text`, bypassing cache and
automatic backend detection. `text` recognises space-separated data
(which includes tab-separated data). Most "plain text" files will give
good results. By default, it loads all the columns of the file, but
only displays the second as a function of the first. If you want to
work on other columns, have a look at [cmd: expand].

Apart from the options of [cmd: dataset-options] and the `/style` and
`/flags` options documented above, the `text` backend accepts several
options controlling the way the text files are interpreted:

  * `/separator` is the text that separate the columns (blank space by
    default. You can use [Qt regular
    expressions](http://qt-project.org/doc/qt-4.8/qregexp.html#introduction)
    enclosed by `/`, such as: `/[;,]/` to split columns on semicolon
    or commas.
  * `/decimal` is the decimal separator (default is the dot).
  * `/comments` is a regular expression describing comment lines (ie
    lines that get ignored). By default, any line that doesn't start
    by a number is ignored.
  * If `/auto-split` is `true`, then `QSoas` will create a new dataset
    everytime it hits a series of blank lines in the file.
  * `/columns` is a series of numbers saying in which order the file
    columns will be used to make a dataset. For instance,
    `/columns=2,1` will swap X and Y at load time.


{::comment} description-end: load-as-text {:/}


{::comment} synopsis-start: load-as-csv {:/}

### load-as-csv - Load files with backend 'csv' {#cmd-load-as-csv}

`load-as-csv` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_ `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers

{::comment} synopsis-end: load-as-csv {:/}
{::comment} description-start: load-as-csv {:/}
The `csv` backend is essentially the same backend as the
[`text`](#cmd-load-as-text) one, but with the separators set by
default to commas and semicolons, to parse CSV files. 
Hence, the options have the same
meaning as for [cmd: load-as-text].
{::comment} description-end: load-as-csv {:/}


{::comment} synopsis-start: expand {:/}

### expand - Expand {#cmd-expand}

`expand` `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/flags=`_texts_

  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define meta-data from perpendicular coordinate
  * `/flags=`_texts_: Buffers to flag/unflag

{::comment} synopsis-end: expand {:/}
{::comment} description-start: expand {:/}
If a buffer contains several columns, QSoas only displays the second as a
function of the first.  expand splits the current buffer into as many
buffers as there are Y columns, ie a X, Y1, Y2, Y3 buffer will be split
into three buffers: X, Y1;   X, Y2 and  X, Y3.
{::comment} description-end: expand {:/}

{::comment} synopsis-start: rename {:/}

### rename - Rename {#cmd-rename}

`rename` _new-name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `a`

  * _new-name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: New name 

{::comment} synopsis-end: rename {:/}
{::comment} description-start: rename {:/}
Changes the current name of the buffer. To help track the
operations applied to a buffer, its name is modified and gets
longer after each modification. `rename` can be used to change
that to give it a more meaningful (and less long) name .
{::comment} description-end: rename {:/}

{::comment} synopsis-start: save {:/}

### save - Save {#cmd-save}

`save` _file_{:title="Path of a file (or a directory)"} `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/mkpath=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `s`

  * _file_{:title="Path of a file (or a directory)"}: File name for saving
  * `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, overwrite without prompting
  * `/mkpath=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, creates all necessary directories

{::comment} synopsis-end: save {:/}
{::comment} description-start: save {:/}
Saves the current buffer to a file.
{::comment} description-end: save {:/}

{::comment} synopsis-start: save-buffers {:/}

### save-buffers - Save {#cmd-save-buffers}

`save-buffers` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/format=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to save
  * `/format=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Overrides buffer names if present

{::comment} synopsis-end: save-buffers {:/}
{::comment} description-start: save-buffers {:/}
Saves the designated buffers to file.

Unlike the [cmd: save] command, this saves the buffers using
their current name, and does not prompt for a file name. It is
probably a good idea to use [cmd: rename] first.
{::comment} description-end: save-buffers {:/}

{::comment} synopsis-start: browse {:/}

### browse - Browse files {#cmd-browse}

`browse` `/pattern=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `W`

  * `/pattern=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Files to browse

{::comment} synopsis-end: browse {:/}
{::comment} description-start: browse {:/}
Browse all datafiles in the current directory (or those matching the
wildcard pattern given to `/pattern`, see [cmd: load] for more
information about wildcards). Very useful to find quickly the file
you're looking for.
{::comment} description-end: browse {:/}


# Data display

{::comment} synopsis-start: overlay-buffer {:/}

### overlay-buffer - Overlay buffers {#cmd-overlay-buffer}

`overlay-buffer` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/style=`_style_{:title="One of: red-blue"}

Alias: `V`

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to overlay
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display

{::comment} synopsis-end: overlay-buffer {:/}
{::comment} description-start: overlay-buffer {:/}
Plots one or several buffers on top of the current buffer.

See [cmd: load] for the description of the `/style` option.
{::comment} description-end: overlay-buffer {:/}

{::comment} synopsis-start: overlay {:/}

### overlay - Overlay {#cmd-overlay}

`overlay` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/style=`_style_{:title="One of: red-blue"} `/flags=`_texts_ `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `v`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/flags=`_texts_: Flags for the newly created buffers
  * `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, ignores what is in the cache
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines

{::comment} synopsis-end: overlay {:/}
{::comment} description-start: overlay {:/}
This command combines [cmd: overlay-buffer] and 
[cmd: load] in one go: loads the files given as arguments and
adds them to the current plot.
{::comment} description-end: overlay {:/}

{::comment} synopsis-start: clear {:/}

### clear - Clear view {#cmd-clear}

`clear` 


{::comment} synopsis-end: clear {:/}
{::comment} description-start: clear {:/}
Removes all datasets except the current buffer from the display. Use to
revert the effect of a previous overlay command, or can be useful if
for some reason a command failed while not restoring the display (but
that really should not happen anyway).
{::comment} description-end: clear {:/}

{::comment} synopsis-start: points {:/}

### points - Show points {#cmd-points}

`points` 

Alias: `poi`


{::comment} synopsis-end: points {:/}
{::comment} description-start: points {:/}
Shows datapoints (by default, datasets are plotted by connecting
datapoints with a line).

Use this with parcimony, as for large datasets, it can significantly
slow down the display.
{::comment} description-end: points {:/}

{::comment} synopsis-start: zoom {:/}

### zoom - Zoom {#cmd-zoom}

`zoom` **(interactive)**

Alias: `z`


{::comment} synopsis-end: zoom {:/}
{::comment} description-start: zoom {:/}
Zooms on the current curve. 

While zooming is already possible to zoom using the mouse wheel, with
this command one draws a rectangle with the mouse around the region of
interest.

{::comment} description-end: zoom {:/}




# Data stack manipulation

Data files are loaded and manipulated in a stack. Every time a file is
loaded or a buffer modified, the new buffer is pushed onto the top of
the stack, and becomes the current buffer (numbered 0). Older buffers
have increasing numbers (the previous buffer is 1, the one before 2,
and so on). There is also a "redo" stack populated by the
[cmd: undo] command. Stack can be manipulated in different
ways:

 * the current buffer can be changed using
   [cmd: undo]/[cmd: redo];
 * buffers can be permanently removed from the stack using
   [cmd: drop];
 * the whole stack can be saved for later use with
   [cmd: save-stack] and restored using
   [cmd: load-stack], or dropped altogether using
   [cmd: clear-stack];
 * contents of the stack can be displayed in the terminal using
   [cmd: show-stack] or in a dialog bog with 
   [cmd: browse-stack].
 * an old buffer can be put back on the top of the stack with
   [cmd: fetch].
 * buffers can be flagged ([cmd: flag]) or unflagged
   ([cmd: unflag]) to be used later using the `flagged`
   buffer selector.


{::comment} synopsis-start: browse-stack {:/}

### browse-stack - Browse stack {#cmd-browse-stack}

`browse-stack` **(interactive)**

Alias: `K`


{::comment} synopsis-end: browse-stack {:/}
{::comment} description-start: browse-stack {:/}
Displays a dialog box to show the current contents of the stack.
{::comment} description-end: browse-stack {:/}

{::comment} synopsis-start: show-stack {:/}

### show-stack - Show stack {#cmd-show-stack}

`show-stack` `/number=`_integer_{:title="An integer"}

Alias: `k`

  * `/number=`_integer_{:title="An integer"} (default): Limit the display to a given number

{::comment} synopsis-end: show-stack {:/}
{::comment} description-start: show-stack {:/}
Shows a small summary of what the stack is made of
{::comment} description-end: show-stack {:/}


{::comment} synopsis-start: redo {:/}

### redo - Redo {#cmd-redo}

`redo` `/number=`_integer_{:title="An integer"}

Alias: `r`

  * `/number=`_integer_{:title="An integer"} (default): Number of operations to undo

{::comment} synopsis-end: redo {:/}
{::comment} description-start: redo {:/}
Pops the last buffer from the redo stack and set it as the current buffer
{::comment} description-end: redo {:/}

{::comment} synopsis-start: undo {:/}

### undo - Undo {#cmd-undo}

`undo` `/number=`_integer_{:title="An integer"}

Alias: `u`

  * `/number=`_integer_{:title="An integer"} (default): Number of operations to undo

{::comment} synopsis-end: undo {:/}
{::comment} description-start: undo {:/}
Returns to the previous buffer, and push the current to the redo stack
{::comment} description-end: undo {:/}

{::comment} synopsis-start: load-stack {:/}

### load-stack - Load stack {#cmd-load-stack}

`load-stack` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File name for saving stack

{::comment} synopsis-end: load-stack {:/}
{::comment} description-start: load-stack {:/}
Loads the stack as saved using save-stack
{::comment} description-end: load-stack {:/}

{::comment} synopsis-start: save-stack {:/}

### save-stack - Save stack {#cmd-save-stack}

`save-stack` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File name for saving stack

{::comment} synopsis-end: save-stack {:/}
{::comment} description-start: save-stack {:/}
Saves the contents of the stack for later use, in a private binary format
{::comment} description-end: save-stack {:/}


{::comment} synopsis-start: clear-stack {:/}

### clear-stack - Clear stack {#cmd-clear-stack}

`clear-stack` 

Alias: `delstack`


{::comment} synopsis-end: clear-stack {:/}
{::comment} description-start: clear-stack {:/}
Removes all the buffers from both normal and redo stack
{::comment} description-end: clear-stack {:/}

{::comment} synopsis-start: fetch {:/}

### fetch - Fetch an old buffer {#cmd-fetch}

`fetch` _buffers..._{:title="Comma-separated lists of datasets in the stack"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to fetch

{::comment} synopsis-end: fetch {:/}
{::comment} description-start: fetch {:/}
Put back a *copy* of the given buffer on the top of the stack. Useful
when you want to work again on a old buffer buried in the stack.
{::comment} description-end: fetch {:/}

{::comment} synopsis-start: drop {:/}

### drop - Drop dataset {#cmd-drop}

`drop` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"}

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to drop

{::comment} synopsis-end: drop {:/}
{::comment} description-start: drop {:/}
Permanently deletes the current dataset (or the ones specified in the
`/buffers` options) from the stack.

~~~~
QSoas> drop 3..16
~~~~ 

drops all the buffers from 3 to 16 included. 

*Important:* it is *not* possible to recover a buffer once it has been
dropped from the stack. [cmd: undo] won't work. Use it only on
buffers you're sure you won't need again (such as computation intermediates). 
{::comment} description-end: drop {:/}
{::comment} synopsis-start: flag {:/}

### flag - Flag datasets {#cmd-flag}

`flag` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} `/flags=`_texts_

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to flag/unflag
  * `/flags=`_texts_: Buffers to flag/unflag

{::comment} synopsis-end: flag {:/}
{::comment} description-start: flag {:/}
Flags the given buffer (or the current one if none is supplied) for
later use. All currently flagged buffers can be specified using the
`flagged` argument to, for instance, [cmd: overlay-buffer].

`QSoas` supports arbitrary text flags, by passing a comma-separated
list of flags to the `/flags=` option. In the absence of that, the
buffers are flagged with the flag name `default`. Buffers can hold
an arbitrary number of flags. For instance:

~~~~
QSoas> flag 0..5 /flags=exp1,fit
~~~~

flags buffers 0 to 5 with the flags `exp1` and `fit`. Buffers are
flagged 'in-place': the current buffer is not changed.

{::comment} description-end: flag {:/}
{::comment} synopsis-start: unflag {:/}

### unflag - Unflag datasets {#cmd-unflag}

`unflag` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} `/flags=`_texts_

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to flag/unflag
  * `/flags=`_texts_: Buffers to flag/unflag

{::comment} synopsis-end: unflag {:/}
{::comment} description-start: unflag {:/}
Removes all flags on the given datasets, or only those specified by
the `/flags` option if the latter is present.
{::comment} description-end: unflag {:/}



# Basic data manipulation at the buffer level

{::comment} synopsis-start: apply-formula {:/}

### apply-formula - Apply formula {#cmd-apply-formula}

`apply-formula` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-columns=`_integer_{:title="An integer"} `/use-stats=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-meta=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `F`

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Formula (valid Ruby code)
  * `/extra-columns=`_integer_{:title="An integer"}: Number of extra columns to create
  * `/use-stats=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a $stats hash is available that contains statistics
  * `/use-meta=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on (by default), a meta hash is available that contains the dataset meta-data

{::comment} synopsis-end: apply-formula {:/}
{::comment} description-start: apply-formula {:/}
Applies a formula to the current dataset. It should specify how the
`x` and/or `y` values of the dataset are modified:

~~~~
QSoas> apply-formula 'x = x**2'
QSoas> apply-formula 'y = sin(x**2)'
QSoas> apply-formula 'x,y = y,x'
~~~~

The last bit swaps the X and Y values of the buffer. The formula must
be valid [ruby](#ruby) code.

In addition to `x` and `y` (note the lowercase !), the formula can
refer to: 

  * `i` (the index of the data point)
  * `y2`, `y3`, etc when there are more than 2 columns in the dataset

`i` cannot be modified, but `y2` and so on can.

Extra columns initially filled with 0 can be created by using the
`/extra-columns` option:

~~~~
QSoas> apply-formula /extra-columns=1 'y2 = y**2'
~~~~

This creates a second column containing the square of the values of
the Y column.

If `/use-stats=true` is used, a global variable `$stats` can be used
within the Ruby expression that contains all the statistics displayed
by [cmd: stats]. For
instance, to normalize the Y values by dividing by the median, one would use:

~~~ 
QSoas> apply-formula /use-stats=true 'y = y/$stats["y_med"]'
~~~

Statistics by segments (see more about segments [there](#segments))
are available too, which means if you want to normalize by the medians
of the first segment, you could do

~~~ 
QSoas> apply-formula /use-stats=true 'y = y/$stats[0]["y_med"]'
~~~

{::comment} description-end: apply-formula {:/}


{::comment} synopsis-start: dx {:/}

### dx - DX {#cmd-dx}

`dx` 


{::comment} synopsis-end: dx {:/}
{::comment} description-start: dx {:/}
Replaces the Y values by the values of delta X, i.e, 
`y[i] = x[i+1] - x[i]`

This is useful to see if the X values are equally spaced.
{::comment} description-end: dx {:/}
{::comment} synopsis-start: dy {:/}

### dy - DY {#cmd-dy}

`dy` 


{::comment} synopsis-end: dy {:/}
{::comment} description-start: dy {:/}
Same as [cmd: dx] but for Y values: replaces the Y values by the
values of delta Y.
{::comment} description-end: dy {:/}

{::comment} synopsis-start: zero {:/}

### zero - Makes 0 {#cmd-zero}

`zero` _value_{:title="A floating-point number"} `/axis=`_axis_{:title="One of: x, y"}

  * _value_{:title="A floating-point number"}: 
  * `/axis=`_axis_{:title="One of: x, y"}: Which axis is zero-ed

{::comment} synopsis-end: zero {:/}
{::comment} description-start: zero {:/}
Given an X value, shifts the Y values so that the point the closest to
the given X value has 0 as Y value.

If `/axis` is `x`, swap X and Y in the above description.
{::comment} description-end: zero {:/}

{::comment} synopsis-start: shiftx {:/}

### shiftx - Shift X values {#cmd-shiftx}

`shiftx` 


{::comment} synopsis-end: shiftx {:/}
{::comment} description-start: shiftx {:/}
Shift X values so that the first point has a X value of 0.
{::comment} description-end: shiftx {:/}

{::comment} synopsis-start: norm {:/}

### norm - Normalize {#cmd-norm}

`norm` `/positive=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/map-to=`_numbers_{:title="Several numbers, separated by :"}

  * `/positive=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we normalize on positive or negative values
  * `/map-to=`_numbers_{:title="Several numbers, separated by :"} (default): Normalizes by mapping to the given segment

{::comment} synopsis-end: norm {:/}
{::comment} description-start: norm {:/}
Normalize the current buffer by its maximum value (or by the absolute
value of its most negative value if `/positive` is `false`).

If the `/map-to` option is specified, the original dataset is mapped
linearly to the given segment: 

~~~~ 
norm /map-to=2:4
~~~~

shifts and scales the original data so that the Y minimum is 2 and the
Y maximum is 4.
{::comment} description-end: norm {:/}


{::comment} synopsis-start: deldp {:/}

### deldp - Deldp {#cmd-deldp}

`deldp` **(interactive)**


{::comment} synopsis-end: deldp {:/}
{::comment} description-start: deldp {:/}
With this command, you can click on given data points to remove
them. Useful to remove a few spikes from the data. Middle click or `q`
to accept the modifications, hit escape to cancel them.
{::comment} description-end: deldp {:/}


{::comment} synopsis-start: edit {:/}

### edit - Edit dataset {#cmd-edit}

`edit` 


{::comment} synopsis-end: edit {:/}
{::comment} description-start: edit {:/}
Pops up a spreadsheet-like window where you can view and edit the
individual values of the current dataset. If you want to save your
modification, press the "push new" button.
{::comment} description-end: edit {:/}

{::comment} synopsis-start: sort {:/}

### sort - Sort {#cmd-sort}

`sort` 


{::comment} synopsis-end: sort {:/}
{::comment} description-start: sort {:/}
Sorts the buffer in increasing X values.
{::comment} description-end: sort {:/}


{::comment} synopsis-start: strip-if {:/}

### strip-if - Strip points {#cmd-strip-if}

`strip-if` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Ruby boolean expression

{::comment} synopsis-end: strip-if {:/}
{::comment} description-start: strip-if {:/}
Removes all points for which the ruby expression returns `true`. This
can be used for quite advanced data selection:

~~~~
QSoas> strip-if 'x > 2'
~~~~ 

This removes all points whose X value is over 2.

~~~~
QSoas> strip-if 'x * y < 10 && x > 2'
~~~~

This removes all the points for which both the X value is over 2 and
the product of X and Y is below 10.

When reading data files that contain spurious data points (such as
text lines containing no data within a file read with
[cmd: load-as-text]), QSoas replaces the missing data
by weird numbers called NaN (Not a Number). They can be useful at
times, but mess up statistics and fits. To remove them, use:

~~~~
QSoas> strip-if '(x != x) || (y != y)'
~~~~


{::comment} description-end: strip-if {:/}

{::comment} synopsis-start: diff {:/}

### diff - Derive {#cmd-diff}

`diff` 


{::comment} synopsis-end: diff {:/}
{::comment} description-start: diff {:/}
Computes the 4th order accurate derivative of the buffer.

This is efficient to compute the derivative of a very smooth
function, but it gives very poor results on noisy data. In general,
for derivation, prefer [cmd: filter-fft] or 
[cmd: filter-bsplines].
{::comment} description-end: diff {:/}

{::comment} synopsis-start: diff2 {:/}

### diff2 - Derive {#cmd-diff2}

`diff2` 


{::comment} synopsis-end: diff2 {:/}
{::comment} description-start: diff2 {:/}
Computes the 4th order accurate second derivative of the buffer. 

The same warnings apply as for [cmd: diff].
{::comment} description-end: diff2 {:/}
{::comment} synopsis-start: dataset-options {:/}

### dataset-options - Options {#cmd-dataset-options}

`dataset-options` `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram

{::comment} synopsis-end: dataset-options {:/}
{::comment} description-start: dataset-options {:/}
Sets options for the current dataset, such as:

 * the display of errors on Y values (you must specify the 0-based
   number of the column in the data: 0 is the X column, 1, the first Y
   column, 2 the 2nd Y column, and so on) {::comment} description-end:
   dataset-options {:/}
 * wether or not the dataset should be displayed looking like a
   histogram
{::comment} description-end: dataset-options {:/}

{::comment} synopsis-start: edit-errors {:/}

### edit-errors - Edit errors {#cmd-edit-errors}

`edit-errors` **(interactive)**


{::comment} synopsis-end: edit-errors {:/}
{::comment} description-start: edit-errors {:/}
Provides an interface for editing manually the errors attached to each
point of the current buffer. This function will create a column
containing errors if there is not one yet.

Pick left and right bounds and set the errors within the bounds with
`i` and outside with `o`.
{::comment} description-end: edit-errors {:/}


## Splitting the dataset in bits (and back)

{::comment} synopsis-start: cut {:/}

### cut - Cut {#cmd-cut}

`cut` **(interactive)**

Alias: `c`


{::comment} synopsis-end: cut {:/}
{::comment} description-start: cut {:/}
Interactively cuts bits out of the buffer. Left and right mouse clicks
set the left and right limits. Middle click or q quits leaving only the
part that is within the region, while u leaves only the outer
part. Hit escape to cancel.
{::comment} description-end: cut {:/}

{::comment} synopsis-start: chop {:/}

### chop - Chop Buffer {#cmd-chop}

`chop` _lengths..._{:title="Several numbers, separated by ,"} `/mode=`_choice_{:title="One of: deltax, index, indices, xvalues"} `/flags=`_texts_ `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _lengths..._{:title="Several numbers, separated by ,"}: Lengths of the subsets
  * `/mode=`_choice_{:title="One of: deltax, index, indices, xvalues"}: Whether to cut on index or x values (default)
  * `/flags=`_texts_: Buffers to flag/unflag
  * `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to actually cut the dataset, or just to set segments where the cuts would have been

{::comment} synopsis-end: chop {:/}
{::comment} description-start: chop {:/}
Cuts the buffer into several parts based on the numbers given as
arguments, and save them as separate
buffers. The intepretation of the numbers depends on the value of the
`/mode` option:

  * `deltax` (default): the numbers are the length (in terms of X) of
    the sub-buffers
  * `xvalues`: the numbers are the X values at which to split
  * `index` (or `indices`): the numbers are the indices of the points
    at which to split

If `/set-segments` is on, the X values not used to create independent
buffers but rather to set the position of the  [segments](#segments).

{::comment} description-end: chop {:/}

{::comment} synopsis-start: splita {:/}

### splita - Split first {#cmd-splita}

`splita` 


{::comment} synopsis-end: splita {:/}
{::comment} description-start: splita {:/}
Returns the first part of the buffer, until the first change of sign
of $$\Delta x$$. 

Useful to get the forward scan of a cyclic voltammogram.
{::comment} description-end: splita {:/}

{::comment} synopsis-start: splitb {:/}

### splitb - Split second {#cmd-splitb}

`splitb` 


{::comment} synopsis-end: splitb {:/}
{::comment} description-start: splitb {:/}
Returns the part of the buffer after the first change of sign
of $$\Delta x$$. 

Useful to get the backward scan of a cyclic voltammogram.
{::comment} description-end: splitb {:/}


{::comment} synopsis-start: split-monotonic {:/}

### split-monotonic - Split into monotonic parts {#cmd-split-monotonic}

`split-monotonic` `/flags=`_texts_

  * `/flags=`_texts_: Buffers to flag/unflag

{::comment} synopsis-end: split-monotonic {:/}
{::comment} description-start: split-monotonic {:/}
Splits the buffer into buffers where all parts have X values that
increase or decrease monotonically.
{::comment} description-end: split-monotonic {:/}
{::comment} synopsis-start: unwrap {:/}

### unwrap - Unwrap {#cmd-unwrap}

`unwrap` 


{::comment} synopsis-end: unwrap {:/}
{::comment} description-start: unwrap {:/}

This command makes the X values of the current buffer monotonic by
ensuring that the value of $$\Delta x$$ always have the same sign,
changing it if needs be.

This is useful for instance to convert a cyclic voltammogram from 
$$i = f(E)$$ to $$i = f(t)$$, after dividing by the scan rate.

{::comment} description-end: unwrap {:/}

{::comment} synopsis-start: cat {:/}

### cat - Concatenate {#cmd-cat}

`cat` _first_{:title="The number of a buffer in the stack"} _second..._{:title="Comma-separated lists of datasets in the stack"} `/add-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `i`

  * _first_{:title="The number of a buffer in the stack"}: First buffer
  * _second..._{:title="Comma-separated lists of datasets in the stack"}: Second buffer(s)
  * `/add-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on (default) segments are added between the old buffers

{::comment} synopsis-end: cat {:/}
{::comment} description-start: cat {:/}
Concatenates the buffers given as arguments, adding segment stops
inbetween (unless `/add-segments=false` is used). This can be used to
reverse the effect of the previous commands.

This does not change the number of columns. If you're trying to gather
several Y columns as a function of the same X, you should try
[cmd: contract] instead.
{::comment} description-end: cat {:/}

## Buffer's meta-data and perpendicular coordinates

QSoas's buffers hold more than just columns of numbers. When a file is
loaded, QSoas also gathers as much information as possible about that
file, such as original file name, file date, and, for files supported
by QSoas, details about the experimental conditions recorded in that
file. These are known as "meta-data", and can be displayed using the
[cmd: show] command.

Here are some meta-data of particular signification available to all
buffers loaded from files:

  * `file-date` is the date of the file
  * `age` is the how old the file was in **seconds** when the current
    `QSoas` session was started.
  * `commands` is the list of commands that have been applied to this
    buffer since its load/creation.

Upon saving using [cmd: save] all of a buffer's meta-data are saved as
comments in the text file.

Perpendicular coordinates make sense when a buffer has several Y
columns. For instance, when data consists in spectra taken at
different times after the beginning of an experiment (or at different
solution potentials for a redox titration), then the X values will be
the wavelength, and each Y column will correspond to a different
time. Then the time is the _perpendicular coordinate_. One can set
the perpendicular coordinate manually using [cmd: set-perp].

Many commands make use of perpendicular, most notably [cmd: transpose]
(that would convert columns of $$y = f(\lambda)$$ for different values
of $$t$$ above into columns of $$y = f(t)$$ for different values
of $$\lambda$$), and all the multi-fit commands that show parameters
as a function of the perpendicular coordinates when applicable.

{::comment} synopsis-start: show {:/}

### show - Show {#cmd-show}

`show` _buffers..._{:title="Comma-separated lists of datasets in the stack"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to show

{::comment} synopsis-end: show {:/}
{::comment} description-start: show {:/}
This command gives detailed information about the buffers given as
arguments, such as the number of rows, columns, segments, but also the
flags the buffer may have, and all its meta-data:

~~~
QSoas> show 0
Dataset 08.oxw: 2 cols, 4975 rows, 1 segments
Flags: 
Meta-data:	delta_t_0 = 950	gpes_file = D:\Vincent\140428\08	original-file = /home/vincent/Data/140428/08.oxw
	age = 428907.581	steps = 1	title = 
	file-date = 2014-05-23T21:23:38	exp-time = 14:03:08	comments = 
	t_0 = 0	E_0 = -0.65	method = chronoamperometry
~~~
 
{::comment} description-end: show {:/}
{::comment} synopsis-start: set-meta {:/}

### set-meta - Set meta-data {#cmd-set-meta}

`set-meta` _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _value_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The name of the meta-data
  * _value_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The meta-data value

{::comment} synopsis-end: set-meta {:/}
{::comment} description-start: set-meta {:/}
Using `set-meta`, one can set the value of the named meta-data for the
current buffer. _name_ can have any value, it does not have to
preexist in the list of buffer's meta-data.
{::comment} description-end: set-meta {:/}

{::comment} synopsis-start: set-perp {:/}

### set-perp - Set perpendicular {#cmd-set-perp}

`set-perp` _coords..._{:title="Several numbers, separated by ,"}

  * _coords..._{:title="Several numbers, separated by ,"}: The values of the coordinates (one for each Y column)

{::comment} synopsis-end: set-perp {:/}
{::comment} description-start: set-perp {:/}
Sets the perpendicular coordinates for the Y columns, as
comma-separated values. For it to be useful, there must be as many
perpendicular coordinates as there are Y columns.
{::comment} description-end: set-perp {:/}

{::comment} synopsis-start: transpose {:/}

### transpose - Transpose {#cmd-transpose}

`transpose` 


{::comment} synopsis-end: transpose {:/}
{::comment} description-start: transpose {:/}
This command transposes the matrix of the Y columns, while paying
attention to the perpendicular coordinates. In short, if one starts
from a series of Y columns representing spectra as a function of
$$\lambda$$ (the X column) for different values of time (each column
at at different value of $$t$$), then after [cmd: transpose], the new
dataset contains columns describing the time evolution of the
absorbance for different values of $$\lambda$$ (one for each column).

{::comment} description-end: transpose {:/}

{::comment} synopsis-start: tweak-columns {:/}

### tweak-columns - Tweak columns {#cmd-tweak-columns}

`tweak-columns` `/remove=`_columns_{:title="A comma-separated list of columns"} `/flip=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/flip-all=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/remove=`_columns_{:title="A comma-separated list of columns"}: The column numbers to remove (X = 1, Y = 2, etc...)
  * `/flip=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, flips all the Y columns
  * `/flip-all=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, flips all the columns, including the X column

{::comment} synopsis-end: tweak-columns {:/}
{::comment} description-start: tweak-columns {:/}
[cmd: tweak-columns] provides basic modifications of columns. If a
[list of columns](#column-names) is given to the `/remove` option,
then the given columns are removed. If `/flip` is on, then all Y
columns are reversed. If `/flip-all` is on, then all columns,
including the X column, are reversed.
{::comment} description-end: tweak-columns {:/}



# Data filtering/processing

QSoas provides different ways to process data to remove unwanted
noise: 

 * Fourier transform filtering using [cmd: filter-fft]
   or [cmd: auto-filter-fft].
 * Data approximation using basis splines via 
   [cmd: filter-bsplines] or 
   [cmd: auto-filter-bs].
 * Splike removals using [cmd: remove-spikes] or 
   which case the [cmd: deldp].

In addition, QSoas provides ways to remove calculated "baselines":

 * baselines interpolated from datapoints with
   [cmd: baseline]
 * baselines interpolated between two segments using either a cubic
   function or an exponential function with
   [cmd: catalytic-baseline]


{::comment} synopsis-start: filter-fft {:/}

### filter-fft - Filter {#cmd-filter-fft}

`filter-fft` `/derive=`_integer_{:title="An integer"} **(interactive)**

  * `/derive=`_integer_{:title="An integer"}: The starting order of derivation

{::comment} synopsis-end: filter-fft {:/}
{::comment} description-start: filter-fft {:/}
Filter data using FFT, ie the data is Fourier transformed, then a
filter function is applied in the frequency domain and the result is
backward transformed.

The cutoff can be changed using the mouse left/right buttons. The
power spectrum can be displayed using the `p` key, and the derivative
can be displayed with `d` (in which case you get the derivative of the
signal when accepting the data).

Behind the scenes, a cubic baseline is computed and subtracted from
the data to ensure that the data to which the FFT is applied has 0
value and 0 derivative on both sides. This greatly reduces artifacts
at the extremities of the dataset. This baseline is computed using a
small heuristic. You can display it using the `b` key.
{::comment} description-end: filter-fft {:/}

{::comment} synopsis-start: filter-bsplines {:/}

### filter-bsplines - Filter {#cmd-filter-bsplines}

`filter-bsplines` `/weight-column=`_column_{:title="The number/name of a column in a buffer"} **(interactive)**

  * `/weight-column=`_column_{:title="The number/name of a column in a buffer"}: Use the weights in the given column

{::comment} synopsis-end: filter-bsplines {:/}
{::comment} description-start: filter-bsplines {:/}

Filters the data using B-splines: B-splines are polynomial functions
of a given order defined over segments. The filtering process finds
the linear combination of these splines functions that is the closest
to the original data.

This approach amounts to taking the projection of the original data
onto the subspace of the polynomial functions.

More information about the polynomial splines used can be found in
the [GSL documentation](http://www.gnu.org/software/gsl/manual/html_node/Overview-of-B_002dsplines.html).  

The result can be tuned by placing "nodes", ie the X positions of the
segments over which the splines are defined. Put more nodes in an area
where the data is not described properly by the smoothed
function. Increasing the order (using `+`) may help too.

Like for [cmd: filter-fft], you can derive the data as
well pushing the `d` key.

Hitting the `o` key optimizes the position of the segments in order
to minimize the difference between the data and the
approximation. (be careful as this function may fail at times).
{::comment} description-end: filter-bsplines {:/}

{::comment} synopsis-start: auto-filter-bs {:/}

### auto-filter-bs - Filter {#cmd-auto-filter-bs}

`auto-filter-bs` `/number=`_integer_{:title="An integer"} `/order=`_integer_{:title="An integer"} `/weight-column=`_column_{:title="The number/name of a column in a buffer"} `/derivatives=`_integer_{:title="An integer"}

Alias: `afbs`

  * `/number=`_integer_{:title="An integer"}: Number of segments
  * `/order=`_integer_{:title="An integer"}: Order of the splines
  * `/weight-column=`_column_{:title="The number/name of a column in a buffer"}: Use the weights in the given column
  * `/derivatives=`_integer_{:title="An integer"}: Compute derivatives up to the given 

{::comment} synopsis-end: auto-filter-bs {:/}
{::comment} description-start: auto-filter-bs {:/}
Filters the data using B-splines in a non-interactive fashion.
Performs automatically an optimization step. 

This is mostly useful in scripts.
{::comment} description-end: auto-filter-bs {:/}


{::comment} synopsis-start: auto-filter-fft {:/}

### auto-filter-fft - Filter {#cmd-auto-filter-fft}

`auto-filter-fft` `/cutoff=`_integer_{:title="An integer"} `/derive=`_integer_{:title="An integer"}

Alias: `afft`

  * `/cutoff=`_integer_{:title="An integer"}: Number of segments
  * `/derive=`_integer_{:title="An integer"}: Differentiate to the given order

{::comment} synopsis-end: auto-filter-fft {:/}
{::comment} description-start: auto-filter-fft {:/}
Filters data using FFT in a non-interactive fashion.
Useful in scripts.
{::comment} description-end: auto-filter-fft {:/}

{::comment} synopsis-start: remove-spikes {:/}

### remove-spikes - Remove spikes {#cmd-remove-spikes}

`remove-spikes` `/number=`_integer_{:title="An integer"} `/factor=`_number_{:title="A floating-point number"} `/force-new=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `R`

  * `/number=`_integer_{:title="An integer"}: Number of points to look at
  * `/factor=`_number_{:title="A floating-point number"}: ...
  * `/force-new=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Adds a new buffer even if no spikes were removed

{::comment} synopsis-end: remove-spikes {:/}
{::comment} description-start: remove-spikes {:/}
Remove spikes using a simple heuristics
{::comment} description-end: remove-spikes {:/}

{::comment} synopsis-start: downsample {:/}

### downsample - Downsample {#cmd-downsample}

`downsample` `/factor=`_integer_{:title="An integer"}

  * `/factor=`_integer_{:title="An integer"}: Downsampling factor

{::comment} synopsis-end: downsample {:/}
{::comment} description-start: downsample {:/}
Creates a buffer with about _factor_ times less points than the
original buffer (default 10 times less) by averaging the original X
and Y values in groups of _factor_.
{::comment} description-end: downsample {:/}


{::comment} synopsis-start: baseline {:/}

### baseline - Baseline {#cmd-baseline}

`baseline` **(interactive)**

Alias: `b`


{::comment} synopsis-end: baseline {:/}
{::comment} description-start: baseline {:/}
Draw a baseline by placing markers on the curve using the mouse (or
off the curve, after using key `o`). Baseline is computing using one
of several interpolation algorithms: C-splines, linear or polynomial
interpolation and Akima splines (the latter usually follows best the
accidents on the curve). Cycle between the various schemes by hitting
`t`.

It is possible to leave saving not the interpolated data, but just the
interpolation ``nodes'' (ie the big dots), by pushing the `p`
key. This has two advantages: first, one can load nodes from a buffer
by hitting the `L` key and providing the buffer number (or just their
X value by hitting `l`). Second, if one has the nodes and just the X
values, one can generate the interpolated data using [cmd: interpolate].

{::comment} description-end: baseline {:/}


{::comment} synopsis-start: interpolate {:/}

### interpolate - Interpolate {#cmd-interpolate}

`interpolate` _xvalues_{:title="The number of a buffer in the stack"} _nodes_{:title="The number of a buffer in the stack"} `/type=`_choice_{:title="One of: Akima spline, C-spline, linear, polynomial"}

  * _xvalues_{:title="The number of a buffer in the stack"}: Base for X values
  * _nodes_{:title="The number of a buffer in the stack"}: Interpolation nodes X/Y values
  * `/type=`_choice_{:title="One of: Akima spline, C-spline, linear, polynomial"}: Interpolation type

{::comment} synopsis-end: interpolate {:/}
{::comment} description-start: interpolate {:/}
Given _xvalues_ and the X/Y position of interpolation nodes saved using
`p` from within [cmd: baseline], this command regenerates the
interpolated values. 

Through this approach, one can draw a baseline, save the points,
generate the baseline-subtracted data using [cmd: interpolate] from
within a script. This has the advantage that one can always have a
close look at the quality of the baseline, and tweak it if need be.

{::comment} description-end: interpolate {:/}

{::comment} synopsis-start: catalytic-baseline {:/}

### catalytic-baseline - Catalytic baseline {#cmd-catalytic-baseline}

`catalytic-baseline` **(interactive)**

Alias: `B`


{::comment} synopsis-end: catalytic-baseline {:/}
{::comment} description-start: catalytic-baseline {:/}
Draws a so-called "catalytic" baseline. There are several types of
baselines, but they all share the following features:

  * they are defined by 4 points
  * the first two points correspond to points where the baseline
    sticks to the data
  * the last two points give a "direction"

There are two baselines implemented for now:

  * a cubic baseline, that goes through the first two points and is
    parallel to the slope of the last two
  * an exponential baseline, that goes through the first two points
    and has the same ratio as the data for the last two points

{::comment} description-end: catalytic-baseline {:/}

{::comment} synopsis-start: auto-correlation {:/}

### auto-correlation - Auto-correlation {#cmd-auto-correlation}

`auto-correlation` 

Alias: `ac`


{::comment} synopsis-end: auto-correlation {:/}
{::comment} description-start: auto-correlation {:/}
Computes the auto-correlation function of the data, using FFT.
{::comment} description-end: auto-correlation {:/}
{::comment} synopsis-start: bin {:/}

### bin - Bin {#cmd-bin}

`bin` `/boxes=`_integer_{:title="An integer"} `/column=`_column_{:title="The number/name of a column in a buffer"} `/log=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/boxes=`_integer_{:title="An integer"}: 
  * `/column=`_column_{:title="The number/name of a column in a buffer"}: 
  * `/log=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 

{::comment} synopsis-end: bin {:/}
{::comment} description-start: bin {:/}
Creates an histogram by binning the Y values (or the values of the
column given by the `/column` option, see [above](#column-names))
into various boxes (whose number can be controlled using the `/boxes`
option). The new buffer has for X values the center of the boxes and
as Y values the number of data points that were in the boxes.
{::comment} description-end: bin {:/}


# Segments {#segments}

It if possible to split a buffer into logical segments without changing
the contents of the buffer, but the position of the segment
boundaries are marked by a vertical line. They can be used for
different purposes: for 
[segment-by-segment operations](#buffer-operations), 
step-by-step film loss correction
(using [cmd: film-loss]) or buffer splitting 
(using [cmd: segments-chop]).

Segments can be detected using
[cmd: find-steps], set manually using
[cmd: set-segments] or [cmd: chop].

{::comment} synopsis-start: find-steps {:/}

### find-steps - Find steps {#cmd-find-steps}

`find-steps` `/average=`_integer_{:title="An integer"} `/threshold=`_number_{:title="A floating-point number"} `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/average=`_integer_{:title="An integer"}: Average over that many points
  * `/threshold=`_number_{:title="A floating-point number"}: Detection threshold
  * `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to set the dataset segments

{::comment} synopsis-end: find-steps {:/}
{::comment} description-start: find-steps {:/}
This function detects ``jumps'' in the data (such as potential changes
in a chronoamperometry experiment, for instance), and display them
both to the terminal output and on the data display. 

By default, this function only shows the segments it finds, but if the
option `/set-segments` is on, the segments are set to that found by
`find-steps` (removing the ones previously there).
{::comment} description-end: find-steps {:/}

{::comment} synopsis-start: set-segments {:/}

### set-segments - Set segments {#cmd-set-segments}

`set-segments` **(interactive)**


{::comment} synopsis-end: set-segments {:/}
{::comment} description-start: set-segments {:/}
Interactively prompts for the addition/removal of segments. A left
click adds a segment where the mouse is, while a right click removes
the closest segment.
{::comment} description-end: set-segments {:/}

{::comment} synopsis-start: segments-chop {:/}

### segments-chop - Chop into segments {#cmd-segments-chop}

`segments-chop` 


{::comment} synopsis-end: segments-chop {:/}
{::comment} description-start: segments-chop {:/}

Cuts the buffer into several ones based on the segments defined in the
current buffer. This way, the effect of a [cmd: chop]
`/set-segment=true` followed by `segments-chop` is the same as the
`chop` without `/set-segment=true`.

{::comment} description-end: segments-chop {:/}
{::comment} synopsis-start: film-loss {:/}

### film-loss - Film loss {#cmd-film-loss}

`film-loss` **(interactive)**


{::comment} synopsis-end: film-loss {:/}
{::comment} description-start: film-loss {:/}
Applies stepwise film loss correction (in the spirit of the $$K_m$$
experiments in [Fourmond _et al_, _Anal. Chem._,
*2009*](http://dx.doi.org/10.1021/ac8025702). For that, the current
buffer must be separated into segments, using
[cmd: set-segments], for instance. `QSoas` then zooms on
the first segment. Right and left clicking around the final linear
decay will set the value of the film loss rate constant for this
step. Push space to switch to the next step, and when you have done
everything, push `q` to obtain the corrected data.
{::comment} description-end: film-loss {:/}



# Operations involving several buffers {#buffer-operations}

It is possible to combine several buffers into one by applying
mathematical operations (subtraction, division and the like). Each of
these processes involve matching a point in a given buffer to a point
in another buffer. There are two ways to do that, chosen by the
`/mode` option:


 * with `/mode=xvalues`, the default, uses the values of X (ie the
   closest X value is picked). **Warning** this doesn't give the
   expected result for buffers with several times the same X values,
   such as full cyclic voltammograms.

 * with `/mode=indices`, points are matched on a one-to-one basis, ie
   point 1 of buffer 1 to point 1 of buffer 2, irrespective of the X
   values.

In addition to that, the operations can make use of the segments
defined on each buffer (see [cmd: find-steps] and
[cmd: set-segments]). If segments are defined and
`/use-segments=true`, then the operations are applied
segment-by-segment, with the first point of each segment matching the
corresponding point in the other buffer. This mode is particularly
useful to manipulate series of potential steps with different time
intervals.

{::comment} synopsis-start: div {:/}

### div - Divide {#cmd-div}

`div` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: div {:/}
{::comment} description-start: div {:/}
Divides all buffers by the last one. This is useful to get rid of film
loss when one has an independent measure of film loss, see
[Fourmond _et al_, Anal. Chem. 2009](http://dx.doi.org/10.1021/ac8025702)
for more information.
{::comment} description-end: div {:/}

{::comment} synopsis-start: subtract {:/}

### subtract - Subtract {#cmd-subtract}

`subtract` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `S`

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: subtract {:/}
{::comment} description-start: subtract {:/}
Subtracts the last buffer from all the other ones (there can be more
than one _first_ buffer). Useful for standard baseline removal.
{::comment} description-end: subtract {:/}

{::comment} synopsis-start: average {:/}

### average - Average {#cmd-average}

`average` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/count=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment
  * `/split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, buffers are automatically split into monotonic parts before averaging.
  * `/count=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a last column contains the number of averaged points for each value

{::comment} synopsis-end: average {:/}
{::comment} description-start: average {:/}
In a manner similar to [cmd: subtract] and
[cmd: divide], the `average` command averages all the
buffers given into one, with the same segment-by-segment capacities.

An additional feature of `average`, though is its ability to first
split the buffers into monotonic parts before averaging (when `/split`
is on). That is even the default in the case when only one buffer is
provided. This proves useful for averaging the forward and return scan
in a cyclic voltammogram.
{::comment} description-end: average {:/}

{::comment} synopsis-start: merge {:/}

### merge - Merge buffers on X values {#cmd-merge}

`merge` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: merge {:/}
{::comment} description-start: merge {:/}
Merge the second buffer with the first one, and keep Y of the second
as a function of Y of the first. The algorithm for finding which point
in the second corresponds to a given one in the first is the same as
that of the other buffers. 

If more than two buffers are specified, the last one gets merged with
each of those before.
{::comment} description-end: merge {:/}

{::comment} synopsis-start: contract {:/}

### contract - Group buffers on X values {#cmd-contract}

`contract` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/use-columns=`_columns_{:title="A comma-separated list of columns"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to contract
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define the perpendicular coordinate from meta-data
  * `/use-columns=`_columns_{:title="A comma-separated list of columns"}: If specified, use only the given columns for the contraction

{::comment} synopsis-end: contract {:/}
{::comment} description-start: contract {:/}
As may be anticipated from the name, `contract` does the reverse of 
[cmd: expand], ie it regroups in one buffer several values
of Y that run against the same values of X. The result is a buffer
that contains as many Y columns as the total of Y columns of all the
arguments. X matching between the buffers is done as for the other
operations such as [cmd: div] or  [cmd: subtract].

You can specify a column list using `/use-columns` (see
[above](#column-names) for more information about column lists), in
which case the other columns from the buffers are ignored.
{::comment} description-end: contract {:/}

# Data inspection facilities

{::comment} synopsis-start: find-peaks {:/}

### find-peaks - Find peaks {#cmd-find-peaks}

`find-peaks` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/which=`_choice_{:title="One of: both, max, min"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/peaks=`_integer_{:title="An integer"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/which=`_choice_{:title="One of: both, max, min"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default
  * `/peaks=`_integer_{:title="An integer"}: Display only that many peaks (by order of intensity)

{::comment} synopsis-end: find-peaks {:/}
{::comment} description-start: find-peaks {:/}
Find all the peaks of the current dataset. If `/output` is on, then
the peak data is written to the output file. This function will find
many peaks on noisy data, you can limit to the first _n_ ones by using 
`/peaks=`_n_ (peaks are ranked by amplitude).

Peaks are indicated on the buffer using lines, and their position is
written to the terminal, if `/output` is on (off by default).
{::comment} description-end: find-peaks {:/}

{::comment} synopsis-start: echem-peaks {:/}

### echem-peaks - Find peaks pairs {#cmd-echem-peaks}

`echem-peaks` 


{::comment} synopsis-end: echem-peaks {:/}
{::comment} description-start: echem-peaks {:/}
This function tries to find "pairs" of peaks that may be the anodic
and cathodic peaks of a redox couple, and outputs useful information
about those.
{::comment} description-end: echem-peaks {:/}

{::comment} synopsis-start: 1 {:/}

### 1 - Find peak {#cmd-1}

`1` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/which=`_choice_{:title="One of: both, max, min"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/which=`_choice_{:title="One of: both, max, min"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default

{::comment} synopsis-end: 1 {:/}
{::comment} description-start: 1 {:/}
Essentially equivalent to 

~~~~
QSoas> find-peaks /peaks=1 /output=true
~~~~
{::comment} description-end: 1 {:/}

{::comment} synopsis-start: 2 {:/}

### 2 - Find two peaks {#cmd-2}

`2` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/which=`_choice_{:title="One of: both, max, min"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/which=`_choice_{:title="One of: both, max, min"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default

{::comment} synopsis-end: 2 {:/}
{::comment} description-start: 2 {:/}
Essentially equivalent to 

~~~~
QSoas> find-peaks /peaks=2 /output=true
~~~~
{::comment} description-end: 2 {:/}


{::comment} synopsis-start: stats {:/}

### stats - Statistics {#cmd-stats}

`stats` `/buffer=`_buffer_{:title="The number of a buffer in the stack"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/buffer=`_buffer_{:title="The number of a buffer in the stack"} (default): An alternative buffer to get information on
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Also write stats to output file
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Make statistics segments by segment

{::comment} synopsis-end: stats {:/}
{::comment} description-start: stats {:/}
`stats` displays various statistics about the current buffer (or the one
specified as the `/buffer` option). The exact list of statistics
displayed grows slowly with time and needs. It is currently, for each
column:

 * the first and last values (displayed with the index)
 * the `_min` and `_max` values
 * the average
 * `_var`, the variance
 * the `_norm`, ie the square root of the sum of the squares
 * for Y columns, the integral is also displayed, indexed by `_int`.

Statistics can be written to the output file with `/to-file=true`. If
you specify `/use-segments=true`, the statistics are also displayed
segment-by-segment (and written out to the output file if asked for).

{::comment} description-end: stats {:/}

{::comment} synopsis-start: cursor {:/}

### cursor - Cursor {#cmd-cursor}

`cursor` **(interactive)**

Alias: `cu`


{::comment} synopsis-end: cursor {:/}
{::comment} description-start: cursor {:/}
Position a cursor on the curve to know its exact X and Y positions. 

Using the right mouse button, it is also possible to position a
reference point. After that the difference in X,Y coordinates between
the cursor and the reference point is also displayed.

Cursor positions can be saved to the output file by pressing the space
bar.

Hitting `u` subtracts the Y value of the current point to the Y values
of the buffer and returns. Hitting `v` divides by the current Y value.

{::comment} description-end: cursor {:/}

{::comment} synopsis-start: reglin {:/}

### reglin - Linear regression {#cmd-reglin}

`reglin` **(interactive)**

Alias: `reg`


{::comment} synopsis-end: reglin {:/}
{::comment} description-start: reglin {:/}
Linear regression. Using the left and right mouse buttons, select a
region whose slope is of interest. The terminal shows the $$a$$ and $$b$$
parameters, and also the effective first order rate constant, ie the
$$k_{eff}$$ parameter of the equation

$$ f_0 \exp \left[-k_{eff} \, (x - x_0) \right] $$

whose first-order expansion gives the same linear approximation, ie:

$$ f_0 \times \left[1 - k_{eff} (x - x_0))\right] = a x + b$$

Using the space bar it is possible to save the values displayed in the
terminal to the output file.
{::comment} description-end: reglin {:/}




# Fits 

QSoas was designed with a particular emphasis on fitting data. It
allows complex fits, and in particular multi-buffer fits, when
functions with shared parameters are fit to different buffers. Fits
fall into two different categories:

 * mono-buffer fits, ie fits that apply to one buffer, but that can be
   applied to several buffers at the same time with shared parameters
 * multi-buffer fits, ie fits that need at least two buffers to work

Fits can be used through several commands: for all fits there are a
`mfit-`_fit_ and a `sim-`_fit_ command, and for mono-buffer fits,
there is a `fit-`_fit_ in addition.

 * The `fit` command fits a single buffer, when the fits allows
   that. It takes no argument
 * The `mfit` command fits several buffers at the same time. It takes
   the numbers of the buffers it will work on.
 * The `sim` command takes a saved parameters file and a series of
   buffers, and pushes the data computed from the parameters on the
   stack using the X values of the buffers given as arguments (their Y
   values are not used).

In addition to these commands, QSoas provides commands to combine fits
together and to fit derivatives of the signals.

All fits commands share several common options, which are detailed
here:

 * With the `/extra-parameters` option, on defines additional
   parameters to the fit, that can be used to define parameters by
   formulas
 * Passing the name of a saved parameters file to the `/parameters`
   option preloads the given parameters at the beginning of the fit.


{::comment} synopsis-start: combine-fits {:/}

### combine-fits - Combine fits {#cmd-combine-fits}

`combine-fits` _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _fits..._

  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The name of the new fit
  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: How to combine the various fits
  * _fits..._: The fit to combine together

{::comment} synopsis-end: combine-fits {:/}
{::comment} description-start: combine-fits {:/}
Creates a new fit named _name_ based on other fits, combined through a
formula. The formula use `y1`, `y2` and so on to refer to the
fits. You specify the fit names by removing the `fit-` or `mfit-`
prefix. For instance, to fit a sum of lorentzians and gaussians, one
just has to do:

~~~
QSoas> combine-fits lg 'y1 + y2' lorentzian gaussian
~~~

This creates a new fit, `lg`, and hence three new commands, `fit-lg`,
`mfit-lg` and `sim-lg`. The fit is a sum of a
[lorentzian](#cmd-fit-lorentzian) fit (`y1`) and a
[gaussian](#cmd-fit-gaussian) fit (`y2`). The new fit shares the
options of all the original fits.  
{::comment} description-end: combine-fits {:/}

{::comment} synopsis-start: define-derived-fit {:/}

### define-derived-fit - Create a derived fit {#cmd-define-derived-fit}

`define-derived-fit` _fit_ `/mode=`_choice_{:title="One of: combined, deriv-only, separated"}

  * _fit_: The fit to make a derived fit of
  * `/mode=`_choice_{:title="One of: combined, deriv-only, separated"}: Whether one fits only the derivative, both the derivative and the original data together or separated

{::comment} synopsis-end: define-derived-fit {:/}
{::comment} description-start: define-derived-fit {:/}
Defines a new fit based on the already defined _fit_ (just the fit
name, that is without the `fit-` prefix) that will fit:

  * only the derivative if `/mode=deriv-only`, in which case is is
    named `fit-deriv-only-`_fit_;
  * a multibuffer fit for the original function in one buffer 
    and the derivative in the second if `/mode=separated` (the default
    mode), in which case the fit is named `mfit-deriv-`_fit_;
  * both the original function and the derivative in a single buffer
    (the derivative is assumed to be the data after the first
    discontinuity in the X values) if `/mode=combined`, in which case
    the new fit is named `fit-deriv-combined-`_fit_;

This function is explained in more details in the [tutorial](tutorial.html).  
{::comment} description-end: define-derived-fit {:/}


## Exponential fits

There are several ways to fit exponentials to data. The simplest is by
far the [cmd: fit-exponential-decay] that
fits a decay with an arbitrary number of exponentials to the data.

{::comment} synopsis-start: fit-exponential-decay {:/}

### fit-exponential-decay - Fit: Multi-exponential fits {#cmd-fit-exponential-decay}

`fit-exponential-decay` `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Wether the sum of exponentials should be multiplied by an exp(-kt) function
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase (that shows up as a linear change in Y against time) ?
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-exponential-decay {:/}
{::comment} description-start: fit-exponential-decay {:/}
Fits to the formula:

$$ \left(A_\infty + \sum_{i=1}^n A_i \exp(-(x - x_0)/\tau_i) + b\,
x\right) \exp (- k_{loss}(x - x_0))$$

$$b\,x$$ is only present if the `/slow` option is on, and $$k_{loss}$$
is not 0 only if `/loss` is on. 
If `/relative` is on, the parameter of the fit is $$\alpha_i$$ 
(defined by $$A_i = \alpha_i A_\infty$$) rather than $$A_i$$.  
This should not be used to fit data that tend to 0.

{::comment} description-end: fit-exponential-decay {:/}

{::comment} synopsis-start: mfit-exponential-decay {:/}

### mfit-exponential-decay - Multi fit: Multi-exponential fits {#cmd-mfit-exponential-decay}

`mfit-exponential-decay` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Wether the sum of exponentials should be multiplied by an exp(-kt) function
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase (that shows up as a linear change in Y against time) ?
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-exponential-decay {:/}
{::comment} description-start: mfit-exponential-decay {:/}
Multi-buffer version of the
[cmd: fit-exponential-decay] fit.
{::comment} description-end: mfit-exponential-decay {:/}


{::comment} synopsis-start: sim-exponential-decay {:/}

### sim-exponential-decay - Fit: Multi-exponential fits {#cmd-sim-exponential-decay}

`sim-exponential-decay` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Wether the sum of exponentials should be multiplied by an exp(-kt) function
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase (that shows up as a linear change in Y against time) ?
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-exponential-decay {:/}
{::comment} description-start: sim-exponential-decay {:/}
Simulation command for the
[cmd: fit-exponential-decay] fit.
{::comment} description-end: sim-exponential-decay {:/}


{::comment} synopsis-start: fit-multiexp-multistep {:/}

### fit-multiexp-multistep - Fit: Multi-step and multi-exponential {#cmd-fit-multiexp-multistep}

`fit-multiexp-multistep` `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-multiexp-multistep {:/}
{::comment} description-start: fit-multiexp-multistep {:/}
Single buffer fit:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: fit-multiexp-multistep {:/}


{::comment} synopsis-start: mfit-multiexp-multistep {:/}

### mfit-multiexp-multistep - Multi fit: Multi-step and multi-exponential {#cmd-mfit-multiexp-multistep}

`mfit-multiexp-multistep` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-multiexp-multistep {:/}
{::comment} description-start: mfit-multiexp-multistep {:/}
multi buffer fit:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: mfit-multiexp-multistep {:/}

{::comment} synopsis-start: sim-multiexp-multistep {:/}

### sim-multiexp-multistep - Fit: Multi-step and multi-exponential {#cmd-sim-multiexp-multistep}

`sim-multiexp-multistep` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-multiexp-multistep {:/}
{::comment} description-start: sim-multiexp-multistep {:/}
fit simulation:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: sim-multiexp-multistep {:/}

## Arbitrary fits

QSoas provides ways to fit arbitrary formulas (written in
[Ruby](#ruby)) to data. While it is possible to do that on a
case-by-case basis using [cmd: fit-arb], it is also
possible to store formulas in a plain text file and load them using 
[cmd: load-fits]. 

Arbitrary fits don't have a corresponding `sim-` command 
(use [cmd: apply-formula] instead).

{::comment} synopsis-start: fit-arb {:/}

### fit-arb - Fit: Arbitrary fit {#cmd-fit-arb}

`fit-arb` _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: \|-separated formulas for the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-arb {:/}
{::comment} description-start: fit-arb {:/}
Fits _formula_ (a piece of [Ruby](#ruby) code) to the current buffer. 

Parameters are auto-detected. Some parameters are treated
specifically:

  * `x_0` and `y_0` are fixed by default and initialized to the first
    X or Y value of the buffer the fit applies to;
  * `temperature` is also fixed and set to the current
    [temperature](#cmd-temperature)
  * Using `fara` counts as using `temperature` excepted that its value is
    $$f = F/RT$$. You never get `fara` as a fit parameter.

If you often use the same formula for `fit-arb`, you should consider
using [cmd: custom-fit] or writing it in a file and
loading that file with [cmd: load-fits].

{::comment} description-end: fit-arb {:/}

{::comment} synopsis-start: mfit-arb {:/}

### mfit-arb - Multi fit: Arbitrary fit {#cmd-mfit-arb}

`mfit-arb` _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: \|-separated formulas for the fit
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-arb {:/}
{::comment} description-start: mfit-arb {:/}
Same as [cmd: fit-arb], but for multiple buffers.

Using `mfit-arb`, it is possible to specify several formulas,
separated by a `\|`. 

If only one formula is specified, the same formula is applied to all
buffers (with, as usual, the possibility to select which parameters
are global or buffer-local).

If more than one formula is specified, the exact same number of
buffers should be supplied; the first formula applies to the first
buffer, the second formula to the second buffer, and so on... For
instance, if you run:

~~~~
QSoas> mfit-arb a*x+b|a*x+c|a*x+d 0 1 2
~~~~

Buffer 0 get fits with `a*x+b`, 1 with `a*x+c` and 2 with `a*x+d`.

{::comment} description-end: mfit-arb {:/}

{::comment} synopsis-start: load-fits {:/}

### load-fits - Load fits {#cmd-load-fits}

`load-fits` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File containing the fits to load

{::comment} synopsis-end: load-fits {:/}
{::comment} description-start: load-fits {:/}
Load fits of arbitrary functions from a plain text file, and create
the corresponding `fit-`, `mfit-` and `sim-` functions, that can be
used with [cmd: define-derived-fit] or
[cmd: combine-fits] for instance. Files should look
like this:

~~~~
# Comments are allowed
michaelis: vmax/(1 + km/x)
sigm-log: log((exp(a_red*log(10.0)) +exp(a_ox*log(10.0)) * \
          exp(-fara*(x-e0)))/ \
          (1 + exp(-fara*(x-e0))))
~~~~

Comments are allowed, as are line continuations with `\`.


{::comment} description-end: load-fits {:/}

{::comment} synopsis-start: custom-fit {:/}

### custom-fit - Define fit {#cmd-custom-fit}

`custom-fit` _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Name for the new fit
  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Mathematical expression for the fit

{::comment} synopsis-end: custom-fit {:/}
{::comment} description-start: custom-fit {:/}
Directly defines a custom fit with the given _name_ and
_formula_. Equivalent to having a line

<pre>
<i>name</i>: <i>formula</i>
</pre>

in a file loaded by [cmd: load-fits].
{::comment} description-end: custom-fit {:/}

## Peak fits

The fits in this section can be used to fit various "peaks" obeying to
different distributions, such as the

 * gaussian distribution [cmd: fit-gaussian]
 * lorentzian distribution [cmd: fit-lorentzian]

For all these fits, you can specify the number of "peaks" using a
common `/number` option. For each peak, there is a position, an
amplitude and a width parameter. If you are more interested in the
total surface under the peak rather than the amplitude of the peak,
the fits provide a `/use-surface` argument that changes the amplitude
parameter into a surface one.

{::comment} synopsis-start: fit-gaussian {:/}

### fit-gaussian - Fit: One or several gaussians {#cmd-fit-gaussian}

`fit-gaussian` `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-gaussian {:/}
{::comment} description-start: fit-gaussian {:/}
Fits a number of gaussians, given by:

$$\sum_i \frac{A_i}{\sqrt{2 \pi {\sigma_i}^2}} 
\exp \left[-\frac{(x-x_i)^2}{2{\sigma_i}^2}\right]$$

More information in the [GSL
documentation](http://www.gnu.org/software/gsl/manual/html_node/The-Gaussian-Distribution.html).

The `/number` option controls the number of different peaks, while
using `/use-surface=true` fits the surface of the peak instead of the
amplitude.
{::comment} description-end: fit-gaussian {:/}
{::comment} synopsis-start: mfit-gaussian {:/}

### mfit-gaussian - Multi fit: One or several gaussians {#cmd-mfit-gaussian}

`mfit-gaussian` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-gaussian {:/}
{::comment} decription-start: mfit-gaussian {:/}
Multi-buffer variant of the [cmd: fit-gaussian] fit.
{::comment} decription-end: mfit-gaussian {:/}
{::comment} synopsis-start: sim-gaussian {:/}

### sim-gaussian - Fit: One or several gaussians {#cmd-sim-gaussian}

`sim-gaussian` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-gaussian {:/}
{::comment} decription-start: sim-gaussian {:/}
Simulation command for the  [cmd: fit-gaussian] fit.
{::comment} decription-end: sim-gaussian {:/}
{::comment} synopsis-start: fit-lorentzian {:/}

### fit-lorentzian - Fit: A Lorentzian (also named Cauchy distribution) {#cmd-fit-lorentzian}

`fit-lorentzian` `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-lorentzian {:/}
{::comment} description-start: fit-lorentzian {:/}
Fits a number of lorentzians, given by:

$$\sum_i 
\frac{A_i}{a_i\pi \left(1 + \left[(x-x_i)/a_i\right]^2\right) }
$$

More information in the [GSL
documentation](http://www.gnu.org/software/gsl/manual/html_node/The-Cauchy-Distribution.html).

The `/number` option controls the number of different peaks, while
using `/use-surface=true` fits the surface of the peak instead of the
amplitude.
{::comment} description-end: fit-lorentzian {:/}
{::comment} synopsis-start: mfit-lorentzian {:/}

### mfit-lorentzian - Multi fit: A Lorentzian (also named Cauchy distribution) {#cmd-mfit-lorentzian}

`mfit-lorentzian` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-lorentzian {:/}
{::comment} description-start: mfit-lorentzian {:/}
Multi-buffer variant of the [cmd: fit-lorentzian] fit.
{::comment} description-end: mfit-lorentzian {:/}
{::comment} synopsis-start: sim-lorentzian {:/}

### sim-lorentzian - Fit: A Lorentzian (also named Cauchy distribution) {#cmd-sim-lorentzian}

`sim-lorentzian` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/number=`_integer_{:title="An integer"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/use-surface=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use a surface or an amplitude parameter
  * `/number=`_integer_{:title="An integer"}: Number of distinct peaks
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-lorentzian {:/}
{::comment} description-start: sim-lorentzian {:/}
Simulation command for the  [cmd: fit-lorentzian] fit.
{::comment} description-end: sim-lorentzian {:/}


## Redox titration fits

{::comment} synopsis-start: fit-nernst {:/}

### fit-nernst - Fit: Nerstian behaviour {#cmd-fit-nernst}

`fit-nernst` `/states=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-nernst {:/}
{::comment} description-start: fit-nernst {:/}
Fits the absorbance (or anything else) of a single chemical species
present under several redox states as a function of the potential,
using the Nernst equation.

The number of redox states is given to the option `/states` (defaults
to 2). The states are numbered from 0, which is the most reduced
state. $$A_i$$ is the absorbance (or whatever else) of the state
numbered $$i$$.

This fit is useful to fit the results of a the redox titration at a
single wavelength. If several wavelength are available, separate them
into several buffers as a function of the potential and fit them using
[cmd: mfit-nernst], while keeping the redox potentials
(and electron numbers) global and only the absorbances as
buffer-local.
{::comment} description-end: fit-nernst {:/}

{::comment} synopsis-start: mfit-nernst {:/}

### mfit-nernst - Multi fit: Nerstian behaviour {#cmd-mfit-nernst}

`mfit-nernst` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/states=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-nernst {:/}
{::comment} description-start: mfit-nernst {:/}
Multi-buffer version of [cmd: fit-nernst]. To be used
for fitting multi-wavelength redox titrations.
{::comment} description-end: mfit-nernst {:/}

{::comment} synopsis-start: sim-nernst {:/}

### sim-nernst - Fit: Nerstian behaviour {#cmd-sim-nernst}

`sim-nernst` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/states=`_integer_{:title="An integer"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-nernst {:/}
{::comment} description-start: sim-nernst {:/}
Simulation command for [cmd: fit-nernst]
{::comment} description-end: sim-nernst {:/}


## Adsorbed ideal redox species


{::comment} synopsis-start: fit-adsorbed {:/}

### fit-adsorbed - Fit: Adsorbed species {#cmd-fit-adsorbed}

`fit-adsorbed` `/species=`_integer_{:title="An integer"} `/2el=`_integer_{:title="An integer"} `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/species=`_integer_{:title="An integer"}: Number of 1-electron species
  * `/2el=`_integer_{:title="An integer"}: Number of true 2-electron species
  * `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true (default) then all species have their own surface concentrations
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-adsorbed {:/}
{::comment} description-start: fit-adsorbed {:/}
Fits a series of "ideal adsorbed peaks" to the current buffer. The
actual formula is the following:

$$ i = \frac{F^2 \nu }{R\,T} 
   \left( \sum_{k} i^{1~el}_k + \sum_{k'} i^{2~el}_{k'}\right) 
$$

The number of 1-electron peaks is given by the `/species` option
(defaults to 1) and that of the 2-electrons peaks is given by the
`/2el` option (defaults to 0).

The current for 1-electron peaks is given by:

$$ 
i^{1~el}_k = \frac{\Gamma_k n_k\,e_k}{\left(1 + {e_k}\right)^2}
$$ 

with $$e_k = \exp \frac{F\,n_k (E - E^0_k)}{R\,T}$$, with $$E^0_k$$
the potential of the couple and $$n_k$$ the apparent number of
electrons. The latter only affects the width of the peaks, the
stoechiometry is always 1 electron.

The current for the 2-electrons peaks is given by[Pilchon and Laviron,
_J. Electronanal. Chem._,
*1976*](http://dx.doi.org/10.1016/S0022-0728(76)80030-7):

$$ 
i^{2~el}_{k'} = \Gamma_{k'} \kappa_{k'}
\frac{\epsilon_{k'} + 4/\kappa_{k'} + 1/\epsilon_{k'}}
{\left(\epsilon_{k'} + \kappa_{k'} + 1/\epsilon_{k'}\right)^2}
$$

With $$\epsilon_{k'} = \exp \frac{F\,(E - E^0_{k'})}{R\,T}$$,
$$E^0_{k'}$$ being the 2-electrons reduction potential (i.e. the
average of those of the 1-electron couples) and 
$$\kappa_{k'} = \exp \frac{F\,\Delta E^0_{k'}}{R\,T}$$, 
$$\Delta E^0_{k'}$$ being the
difference in the reduction potentials of the 1-electron couples (it
is positive if the intermediate species is thermodynamically stable).

The $$\Gamma$$ parameters are the number of moles of the molecules
adsorbed on the electrode (there is no explicit surface). If the
option `/distinct=false` is used, the same value of $$\Gamma$$ is used
for all couples, while in the other case (the default), each couple
has its own value of $$\Gamma$$ (which corresponds to unrelated
species). $$\nu$$ is the voltammetric scan rate (in volts per second).

{::comment} description-end: fit-adsorbed {:/}

{::comment} synopsis-start: mfit-adsorbed {:/}

### mfit-adsorbed - Multi fit: Adsorbed species {#cmd-mfit-adsorbed}

`mfit-adsorbed` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/species=`_integer_{:title="An integer"} `/2el=`_integer_{:title="An integer"} `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/species=`_integer_{:title="An integer"}: Number of 1-electron species
  * `/2el=`_integer_{:title="An integer"}: Number of true 2-electron species
  * `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true (default) then all species have their own surface concentrations
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-adsorbed {:/}
{::comment} description-start: mfit-adsorbed {:/}
Multi-buffer version of the [fit: adsorbed] fit.
{::comment} description-end: mfit-adsorbed {:/}


{::comment} synopsis-start: sim-adsorbed {:/}

### sim-adsorbed - Fit: Adsorbed species {#cmd-sim-adsorbed}

`sim-adsorbed` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/species=`_integer_{:title="An integer"} `/2el=`_integer_{:title="An integer"} `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/species=`_integer_{:title="An integer"}: Number of 1-electron species
  * `/2el=`_integer_{:title="An integer"}: Number of true 2-electron species
  * `/distinct=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true (default) then all species have their own surface concentrations
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-adsorbed {:/}
{::comment} description-start: sim-adsorbed {:/}
Simulation command for the [fit: adsorbed] fit.
{::comment} description-end: sim-adsorbed {:/}


## Kinetic systems {#kinetic-systems}

It is possible with QSoas to fit kinetic traces that follow the
concentration of one or more species that are part of a full kinetic
system. For that, you need to write a simple text file of the
following form:

~~~~
A <=>[k_i][k_a] I1
I1 ->[k_i2 * o2] I2
~~~~

This describes a kinetic system with three species, `A`, `I1` and
`I2`, with a reversible reaction from `A` to `I1` with a forward
rate of `k_i` and a backward rate of `k_a`, and an irreversible
reaction from `I1` to `I2` with a rate of `k_i2 * o2`. 

The files can contain comment lines starting with a `#`, and can
contain an arbitrary large number of reactions.

QSoas automatically detects the parameters from the fit, here `k_i`,
`k_a`, `k_i2` and `o2`.

It is possible to assign special time dependence to any of the
parameters by using the `/with` option: 

~~~~
QSoas> fit-kinetic-system /with=o2:3,exp kinetic-file.txt
~~~~

This gives to `o2` the value of the sum of three exponential decays
shifted in time (see formula below).

There is for now only one type of time-dependence:

  * `exp`, where the given parameter, `p` is given by:

  $$ p = \sum_{i=1}^n p_i \exp \left( - \frac{t -
  t^p_i}{\tau^p_i}\right) \times H(t - t^p_i)$$

  where $$H$$ is the heavyside step function (1 for positive argument,
  0 else) and $$n$$ is the number given just after `:` (in the above
  command-line, that means you will have three different steps). You
  may wish to have all $$\tau$$ values common, which you do by adding
  `,common` in the spec:

~~~~
QSoas> fit-kinetic-system /with=o2:3,exp,common kinetic-file.txt
~~~~

This kind of functions were used to analyse the inhibition of NiFe
hydrogenase by CO and O2, see for instance [Liebgott _et al_,
_Nat. Chem. Biol._, 2010](http://dx.doi.org/10.1038/nchembio.276).

To define a new fit one could combine with others using 
[cmd: combine-fits], use [cmd: define-kinetic-system-fit].


{::comment} synopsis-start: fit-kinetic-system {:/}

### fit-kinetic-system - Fit: Full kinetic system {#cmd-fit-kinetic-system}

`fit-kinetic-system` _system_{:title="Path of a file (or a directory)"} `/with=`_texts_ `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/min-step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/sub-steps=`_integer_{:title="An integer"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/min-step-size=`_number_{:title="A floating-point number"}: Minimum step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/sub-steps=`_integer_{:title="An integer"}: If this is not 0, then the smallest step size is that number times less than the minimum delta t
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-kinetic-system {:/}
{::comment} description-start: fit-kinetic-system {:/}
Fits a full kinetic system. The fitted value is a linear combination
of all the concentrations, with the coefficients given by parameters
of name `y_A` (for the coefficient for the concentration of species
`A`, for instance).
{::comment} description-end: fit-kinetic-system {:/}

{::comment} synopsis-start: mfit-kinetic-system {:/}

### mfit-kinetic-system - Multi fit: Full kinetic system {#cmd-mfit-kinetic-system}

`mfit-kinetic-system` _system_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/with=`_texts_ `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/min-step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/sub-steps=`_integer_{:title="An integer"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/min-step-size=`_number_{:title="A floating-point number"}: Minimum step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/sub-steps=`_integer_{:title="An integer"}: If this is not 0, then the smallest step size is that number times less than the minimum delta t
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-kinetic-system {:/}
{::comment} description-start: mfit-kinetic-system {:/}
Multi-buffer variant of the
[`kinetic-system`](#cmd-fit-kinetic-system) fit.
{::comment} description-end: mfit-kinetic-system {:/}

{::comment} synopsis-start: sim-kinetic-system {:/}

### sim-kinetic-system - Fit: Full kinetic system {#cmd-sim-kinetic-system}

`sim-kinetic-system` _system_{:title="Path of a file (or a directory)"} _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/with=`_texts_ `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/min-step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/sub-steps=`_integer_{:title="An integer"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/choose-t0=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/min-step-size=`_number_{:title="A floating-point number"}: Minimum step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/sub-steps=`_integer_{:title="An integer"}: If this is not 0, then the smallest step size is that number times less than the minimum delta t
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-kinetic-system {:/}
{::comment} description-start: sim-kinetic-system {:/}
Computation for the 
[`kinetic-system`](#cmd-fit-kinetic-system) fit.
{::comment} description-end: sim-kinetic-system {:/}

{::comment} synopsis-start: define-kinetic-system-fit {:/}

### define-kinetic-system-fit - Define a fit based on a kinetic mode {#cmd-define-kinetic-system-fit}

`define-kinetic-system-fit` _file_{:title="Path of a file (or a directory)"} _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _file_{:title="Path of a file (or a directory)"}: System to load
  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: 

{::comment} synopsis-end: define-kinetic-system-fit {:/}
{::comment} description-start: define-kinetic-system-fit {:/}
In the [cmd: fit-kinetic-system] fit, one has to provide
systematically the name of the file that contains the kinetic system.
This can be annoying at times, and it makes it impossible to use these
fits with [cmd: combine-fits] or [cmd: define-derived-fit].

This command makes it possible to define a new fit for the kinetic
system contained in _file_. The kinetic system is read once: further
changes in the file will **not** be taken into account.
{::comment} description-end: define-kinetic-system-fit {:/}




## Slow scans fits

These specific fits were used in the context of the interpretation of
cyclic voltammograms of adorbed nickel-iron hydrogenase that undergo
inactivations under oxidizing conditions. For more information, refer
to [Abou-Hamdam _et al_, __PNAS__ 2012](http://dx.doi.org/10.1073/pnas.1212258109)
(which you probably should cite anyway if you use them).

{::comment} synopsis-start: fit-slow-scan-hp {:/}

### fit-slow-scan-hp - Fit: Slow scan test {#cmd-fit-slow-scan-hp}

`fit-slow-scan-hp` `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-slow-scan-hp {:/}
{::comment} description-start: fit-slow-scan-hp {:/}
Fit for the "high-potential" part of a slow voltammetric scan where
inactivation occurs with rate constants that do not depend on
time. The current for the active form is assumed to depend linearly on
the potential.

Formula:

$$ i_{forward} = (a + b \times E) \left[\left(A_1 - A_e\right) \times \exp\left\{-(E E_1)/(\nu \tau)\right\} + A_e\right]  $$

$$ i_{backward} = (a + b \times E) \left[\left(A_1 - A_e\right) \times \exp\left\{-(2E_v-E_1-E)/(\nu \tau)\right\} + A_e\right]  $$

where $$E_v$$ is the vertex potential, $$E_1$$ is the initial potential,
$$\tau$$ the rate constant of decrease, $$A_1$$ the amount of initially
active enzyme, $$A_e$$ the equilibrium concentration of active species
and $\nu$ the scan rate.

{::comment} description-end: fit-slow-scan-hp {:/}

{::comment} synopsis-start: fit-slow-scan-lp {:/}

### fit-slow-scan-lp - Fit: Slow scan test {#cmd-fit-slow-scan-lp}

`fit-slow-scan-lp` `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-slow-scan-lp {:/}
{::comment} description-start: fit-slow-scan-lp {:/}
Fit for the "low-potential" part of a slow voltammetric scan where the
enzyme reactivates with a rate constant that depends exponentially on
the potential: 

$$ k_a = k \exp(- \alpha f E)$$

The overall formula is:

$$ i(E) = \underbrace{(A\times E+B)}_{\text{stationnary current}}
   \underbrace{\left(  1 - (1-y_1) \exp^{-\frac{k}{\alpha f \nu}
   (\exp^{\alpha f E}-\exp^{\alpha f E_1})}\right)}_
   {\text{active fraction}} $$

$$E_1$$ is the initial potential, $$\nu$$ the scan rate

{::comment} description-end: fit-slow-scan-lp {:/}

{::comment} synopsis-start: mfit-slow-scan-hp {:/}

### mfit-slow-scan-hp - Multi fit: Slow scan test {#cmd-mfit-slow-scan-hp}

`mfit-slow-scan-hp` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-slow-scan-hp {:/}
{::comment} description-start: mfit-slow-scan-hp {:/}
Multi-buffer variant of the
[cmd: fit-slow-scan-hp] fit.
{::comment} description-end: mfit-slow-scan-hp {:/}

{::comment} synopsis-start: mfit-slow-scan-lp {:/}

### mfit-slow-scan-lp - Multi fit: Slow scan test {#cmd-mfit-slow-scan-lp}

`mfit-slow-scan-lp` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-slow-scan-lp {:/}
{::comment} description-start: mfit-slow-scan-lp {:/}
Multi-buffer variant of the
[cmd: fit-slow-scan-lp] fit.
{::comment} description-end: mfit-slow-scan-lp {:/}

{::comment} synopsis-start: sim-slow-scan-lp {:/}

### sim-slow-scan-lp - Fit: Slow scan test {#cmd-sim-slow-scan-lp}

`sim-slow-scan-lp` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-slow-scan-lp {:/}
{::comment} description-start: sim-slow-scan-lp {:/}
Computation for the 
[`slow-scan-lp`](#cmd-fit-slow-scan-lp) fit.
{::comment} description-end: sim-slow-scan-lp {:/}

{::comment} synopsis-start: sim-slow-scan-hp {:/}

### sim-slow-scan-hp - Fit: Slow scan test {#cmd-sim-slow-scan-hp}

`sim-slow-scan-hp` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-slow-scan-hp {:/}
{::comment} description-start: sim-slow-scan-hp {:/}
Computation for the 
[`slow-scan-hp`](#cmd-fit-slow-scan-hp) fit.
{::comment} description-end: sim-slow-scan-hp {:/}



## Wave shape fits

These fits correspond to the various models described in 
[Fourmond _et al_, *JACS*2013](http://dx.doi.org/10.1021/ja311607s):

 * [cmd: fit-eecr-wave] is the *EEC* model
 * [cmd: fit-ecr-wave] is the *EC* model
 * [cmd: fit-eecr-relay-wave] is the *EECR*
   model

Please refer to that paper for more information.


{::comment} synopsis-start: fit-eecr-wave {:/}

### fit-eecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-fit-eecr-wave}

`fit-eecr-wave` `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-eecr-wave {:/}
{::comment} description-start: fit-eecr-wave {:/}
Fits the so-called EEC model in [Fourmond _et al_, *JACS*2013](http://dx.doi.org/10.1021/ja311607s) 
to the data.

If `/plateau` is off (default), then the equation used is that for the
limit where the dispersion of values of $$k_0$$ 
large $$\beta d_0 \to \infty$$, while the full expression is used in
the other case.

If `/oxidation` is true, the reference current is the oxidation current
(and not the reduction current as is the default).

If `/use-eoc` is true, then the open circuit potential is used as a
parameter rather than the ratio $$k_2/k_{-2}$$.
{::comment} description-end: fit-eecr-wave {:/}


{::comment} synopsis-start: mfit-eecr-wave {:/}

### mfit-eecr-wave - Multi fit: Fit of an EECR catalytic wave {#cmd-mfit-eecr-wave}

`mfit-eecr-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-eecr-wave {:/}
{::comment} description-start: mfit-eecr-wave {:/}
Multi-buffer variant of [cmd: fit-eecr-wave].
{::comment} description-end: mfit-eecr-wave {:/}

{::comment} synopsis-start: sim-eecr-wave {:/}

### sim-eecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-sim-eecr-wave}

`sim-eecr-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-eecr-wave {:/}
{::comment} description-start: sim-eecr-wave {:/}
Simulation for the [`eecr-wave`](#cmd-fit-eecr-wave) fit.
{::comment} description-end: sim-eecr-wave {:/}


{::comment} synopsis-start: fit-eecr-relay-wave {:/}

### fit-eecr-relay-wave - Fit: Fit of an EECR+relay catalytic wave {#cmd-fit-eecr-relay-wave}

`fit-eecr-relay-wave` `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-eecr-relay-wave {:/}
{::comment} description-start: fit-eecr-relay-wave {:/}
Fits the so-called EEC with relay model in [Fourmond _et al_,
*JACS*2013](http://dx.doi.org/10.1021/ja311607s) to the data.
{::comment} description-end: fit-eecr-relay-wave {:/}

{::comment} synopsis-start: mfit-eecr-relay-wave {:/}

### mfit-eecr-relay-wave - Multi fit: Fit of an EECR+relay catalytic wave {#cmd-mfit-eecr-relay-wave}

`mfit-eecr-relay-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-eecr-relay-wave {:/}
{::comment} description-start: mfit-eecr-relay-wave {:/}
Multi-buffer version of the [`eecr-relay-wave`](#cmd-fit-eecr-relay-wave) fit.
{::comment} description-end: mfit-eecr-relay-wave {:/}
{::comment} synopsis-start: sim-eecr-relay-wave {:/}

### sim-eecr-relay-wave - Fit: Fit of an EECR+relay catalytic wave {#cmd-sim-eecr-relay-wave}

`sim-eecr-relay-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-eecr-relay-wave {:/}
{::comment} description-start: sim-eecr-relay-wave {:/}
Simulation command for the [`eecr-relay-wave`](#cmd-fit-eecr-relay-wave) fit.
{::comment} description-end: sim-eecr-relay-wave {:/}

{::comment} synopsis-start: fit-ecr-wave {:/}

### fit-ecr-wave - Fit: Fit of an ECR catalytic wave {#cmd-fit-ecr-wave}

`fit-ecr-wave` `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ **(interactive)**

  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data

{::comment} synopsis-end: fit-ecr-wave {:/}
{::comment} description-start: fit-ecr-wave {:/}
Fits the so-called EC model in [Fourmond _et al_,
*JACS*2013](http://dx.doi.org/10.1021/ja311607s) to the data.
{::comment} description-end: fit-ecr-wave {:/}
{::comment} synopsis-start: mfit-ecr-wave {:/}

### mfit-ecr-wave - Multi fit: Fit of an ECR catalytic wave {#cmd-mfit-ecr-wave}

`mfit-ecr-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/set-from-meta=`_texts_ `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/set-from-meta=`_texts_: Set parameter values from meta-data
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)
  * `/perp-meta=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: If specified, it is the name of a meta-data that holds the perpendicular coordinates

{::comment} synopsis-end: mfit-ecr-wave {:/}
{::comment} description-start: mfit-ecr-wave {:/}
Multi-buffer version of the [`ecr-wave`](#cmd-fit-ecr-wave) fit.
{::comment} description-end: mfit-ecr-wave {:/}
{::comment} synopsis-start: sim-ecr-wave {:/}

### sim-ecr-wave - Fit: Fit of an ECR catalytic wave {#cmd-sim-ecr-wave}

`sim-ecr-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-ecr-wave {:/}
{::comment} description-start: mfit-ecr-wave {:/}
Simulation command for the [`ecr-wave`](#cmd-fit-ecr-wave) fit.
{::comment} description-end: mfit-ecr-wave {:/}

# Computation/simulations functions

The commands in this section generate data "from scracth", though most
require a buffer to work on, to act as a model for the X values. You
can create a buffer for those commands using
[cmd: generate-buffer]. 

## Evaluation functions

While it is not its primary purpose, QSoas provides various functions
to evaluate the result of mathematical operations.

{::comment} synopsis-start: eval {:/}

### eval - Ruby eval {#cmd-eval}

`eval` _code_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _code_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Any ruby code

{::comment} synopsis-end: eval {:/}
{::comment} description-start: eval {:/}
Evaluates the given code as a Ruby expression:

~~~~
QSoas> eval 2*3
 => 6
~~~~

It runs in the same environment as the
[cmd: apply-formula] and the custom fits (excepted,
of course, that there are no `x` and `y` variables). It can be useful
to check that a function has been correctly defined in a file loaded
by [cmd: ruby-run].
{::comment} description-end: eval {:/}

{::comment} synopsis-start: find-root {:/}

### find-root - Finds a root {#cmd-find-root}

`find-root` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _seed_{:title="A floating-point number"} `/max=`_number_{:title="A floating-point number"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: An expression of 1 variable (not an equation !)
  * _seed_{:title="A floating-point number"}: Initial X value from which to search
  * `/max=`_number_{:title="A floating-point number"} (default): If present, uses dichotomy between seed and max

{::comment} synopsis-end: find-root {:/}
{::comment} description-start: find-root {:/}

Find the root of the given `x`-dependent expression using an iterative
algorithm, using _seed_ as the initial value. If the `/max` option is
specified, then the search proceeds using dichotomy between the two
values (_seed_ and _max_).

~~~~
QSoas> find-root 'x**2 - 3' 1
Found root at: 1.73205
~~~~

Do not use a equal sign. The returned value is that for which the
expression equates 0.
{::comment} description-end: find-root {:/}
{::comment} synopsis-start: integrate-formula {:/}

### integrate-formula - Integrate expression {#cmd-integrate-formula}

`integrate-formula` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _a_{:title="A floating-point number"} _b_{:title="A floating-point number"} `/integrator=`_choice_{:title="One of: gauss15, gauss21, gauss31, gauss41, gauss51, gauss61, qng"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: An expression of 1 variable (not an equation !)
  * _a_{:title="A floating-point number"}: Left bound of the segment
  * _b_{:title="A floating-point number"}: Right bound of the segment
  * `/integrator=`_choice_{:title="One of: gauss15, gauss21, gauss31, gauss41, gauss51, gauss61, qng"}: The algorithm used for integration
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required for integration
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required for integration

{::comment} synopsis-end: integrate-formula {:/}
{::comment} description-start: integrate-formula {:/}
Computes the integral of the given expression of `x` between bounds
_a_ and _b_:

~~~~
QSoas> integrate-formula x**2 10 22
Integral value: 3216	estimated error: 3.57048e-11	 in 31 evaluations over 1 intervals 
~~~~

{::comment} description-end: integrate-formula {:/}

{::comment} synopsis-start: generate-buffer {:/}

### generate-buffer - Generate buffer {#cmd-generate-buffer}

`generate-buffer` _start_{:title="A floating-point number"} _end_{:title="A floating-point number"} `/samples=`_integer_{:title="An integer"} `/formula=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _start_{:title="A floating-point number"}: The first X value
  * _end_{:title="A floating-point number"}: The last X value
  * `/samples=`_integer_{:title="An integer"}: The number of samples
  * `/formula=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Formula to generate the Y values

{::comment} synopsis-end: generate-buffer {:/}
{::comment} description-start: generate-buffer {:/}
Generates a buffer with _samples_ samples (by default 1000) uniformly
spaced between _start_ and _end_.

If formula is provided, it sets Y values according to this formula
(else Y is take equal to X).


~~~~
QSoas> generate-buffer -10 10 sin(x)
~~~~
{::comment} description-end: generate-buffer {:/}

## Simulation functions



{::comment} synopsis-start: kinetic-system {:/}

### kinetic-system - Kinetic system evolver {#cmd-kinetic-system}

`kinetic-system` _reaction-file_{:title="Path of a file (or a directory)"} _parameters_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/dump=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/min-step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/sub-steps=`_integer_{:title="An integer"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _reaction-file_{:title="Path of a file (or a directory)"}: File describing the kinetic system
  * _parameters_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Parameters of the model
  * `/dump=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, dumps the system rather than solving
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/min-step-size=`_number_{:title="A floating-point number"}: Minimum step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/sub-steps=`_integer_{:title="An integer"}: If this is not 0, then the smallest step size is that number times less than the minimum delta t
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a last column will contain the number of function evaluation for each step

{::comment} synopsis-end: kinetic-system {:/}
{::comment} description-start: kinetic-system {:/}
Simulates the evolution over time of the [kinetic
system](#kinetic-systems) given in the _reaction-file_ (see the
section [kinetic system](#kinetic-systems) for the syntax of the
reaction files).

This commands will use the current buffer as a source for X values. 

The result is a multi-column buffer containing the concentration of
all the species in the different columns.

_parameters_ is a list of assignments evaluated at the beginning of the
time evolution to set the parameters of the system. (all parameters
not set this way default to 0).

For instance, if the reaction file (`system.sys`) contains:

~~~
A <=>[ki][ka] I
~~~

You can run the following commands to simulate the time evolution of
the system with initial concentration of A equal to 1 (the parameter
`c0_A`), of I equal to 0 (the parameter `c0_I`, here not specified so
assumed to be 0) and with `ki` and `ka` equal to 1:

~~~
QSoas> generate-buffer 0 10
QSoas> kinetic-system system.sys 'c0_A = 1;ka = 1; ki = 1'
~~~

The _parameters_ argument is actually a [Ruby](#ruby) expression that
is evaluated once before the computations start, so you can use more
complex formulas.

{::comment} description-end: kinetic-system {:/}


{::comment} synopsis-start: ode {:/}

### ode - ODE solver {#cmd-ode}

`ode` _file_{:title="Path of a file (or a directory)"} `/parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/min-step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/sub-steps=`_integer_{:title="An integer"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}

  * _file_{:title="Path of a file (or a directory)"}: File containing the system
  * `/parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Values of the extra parameters
  * `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a last column will contain the number of function evaluation for each step
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/min-step-size=`_number_{:title="A floating-point number"}: Minimum step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/sub-steps=`_integer_{:title="An integer"}: If this is not 0, then the smallest step size is that number times less than the minimum delta t
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration

{::comment} synopsis-end: ode {:/}
{::comment} description-start: ode {:/}
`ode` solves ordinary differential equations. The equation definition
file is structure in three parts, separated by at least one fully
blank line, the last one being optional. 

The first section defines the "initial conditions"; there are as many
integrated variables as there are lines in this section. This section
is only evaluated at the beginning of the system.

The second section defines the derivatives; they are evaluated several
times for each time step. 

Here is the contents of the file (say `sine.ode`) one would use to
obtain $$\sin t$$ and $$\cos t$$ as solutions.

~~~
sin = 0
cos = 1

d_sin = cos
d_cos = -sin
~~~

After running the commands

~~~
QSoas> generate-buffer 0 10
QSoas> ode sine.ode
~~~

One has a buffer with one X column (representing the $$t$$ values),
and two Y columns, $$\sin t$$ and $$\cos t$$ (in the order in which
they are given in the "initial conditions" section).

The optional third section can be used to control the exact output of
the program. The above example can be completed thus:

~~~
sin = 0
cos = 1

d_sin = cos
d_cos = -sin

[sin, cos, sin**2 + cos**2]
~~~

Using this gives 3 Y columns: $$\sin t$$, $$\cos t$$ and 
$$\sin^2 t + \cos^2 t$$, that should hopefully be very close to 1.

Details of the integrations procedures can be tweaked using the
parameters:

 * `/stepper`: the ODE stepper algorithm. You can find more about them
   in the [GSL documentation](http://www.gnu.org/software/gsl/manual/html_node/Stepping-Functions.html)
 * `/prec-relative` and `/prec-absolute` control the precision. A step
   will be deemed precise enough if the error estimate is **either**
   smaller than the relative precision or than the absolute precision
 * `/adaptative` controls whether an adaptative step size is used (the
   values of $$t$$ in the resulting buffer are always those asked, but
   there may be more intermediate steps). You should seldom need to
   turn it off

If `/annotate` is on, a last column is added that contains the number
of the evaluations of derivatives for each step (useful for
understanding why an integration takes so long, for instance).

The system of equations may contain undefined variables; one could
have for instance used:

~~~
d_sin = omega * cos
d_cos = -omega * sin
~~~

Their values are set to 0 by default. You can change their values
using the `/parameters` option:

~~~
QSoas> ode sine.ode /parameters="omega = 3"
~~~

{::comment} description-end: ode {:/}


# Scripting facilities {#scripting}

QSoas provides facilities for scripting, ie running commands
unattended, for instance for preparing series of data files for
fitting or further use. There are a few commands useful only in this
context, such as the following


## Scripting commands

{::comment} synopsis-start: run {:/}

### run - Run commands {#cmd-run}

`run` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `@`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: First is the command files, following are arguments
  * `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not display is updated during the load
  * `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the commands run are added to the history (defaults to false)

{::comment} synopsis-end: run {:/}
{::comment} description-start: run {:/}
Run commands saved in a file. If a compulsory argument is missing,
QSoas will prompt the user.

Arguments following the name of the script are passed to the script as
"special variables" ${1}, and ${2} etc.

Imagine you are often doing the same processing a given type of data
files, say, simply filtering them. You just have to write a script
`process.cmd` containing:

~~~~
load ${1}
auto-filter-fft 
~~~~

And run it this way:

~~~~
QSoas> @ process.cmd data_file.dat
~~~~

If you start to use `run` regularly, you may be interested in the
other scripting commands, such as [cmd: run-for-each],
[cmd: run-for-datasets] and
[cmd: startup-files]

{::comment} description-end: run {:/}


{::comment} synopsis-start: startup-files {:/}

### startup-files - Startup files {#cmd-startup-files}

`startup-files` `/add=`_file_{:title="Path of a file (or a directory)"} `/rm=`_integer_{:title="An integer"} `/run=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/add=`_file_{:title="Path of a file (or a directory)"} (default): Adds the given startup file
  * `/rm=`_integer_{:title="An integer"}: Removes the numbered file
  * `/run=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, runs all the startup files right now

{::comment} synopsis-end: startup-files {:/}
{::comment} description-start: startup-files {:/}
Using this command, you can instruct `QSoas` to execute command files
at startup. Without options, this command displays the list of command
files that `QSoas` will read at the next startup.

Files given to the `/add` options are added at the end of the list.

To remove a fil from the list, obtain its number by running
startup-fileswithout any option, then use
startup-files again with the option /rm=.

You can re-run all startup files by running:

~~~
QSoas> startup-files /run=true
~~~

{::comment} description-end: startup-files {:/}
{::comment} synopsis-start: run-for-each {:/}

### run-for-each - Runs a script for several arguments {#cmd-run-for-each}

`run-for-each` _script_{:title="Path of a file (or a directory)"} _arguments..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/arg2=`_file_{:title="Path of a file (or a directory)"} `/arg3=`_file_{:title="Path of a file (or a directory)"} `/arg4=`_file_{:title="Path of a file (or a directory)"} `/arg5=`_file_{:title="Path of a file (or a directory)"} `/arg6=`_file_{:title="Path of a file (or a directory)"} `/range-type=`_choice_{:title="One of: lin, log"} `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _script_{:title="Path of a file (or a directory)"}: The script file
  * _arguments..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: All the arguments for the script file to loop on
  * `/arg2=`_file_{:title="Path of a file (or a directory)"}: Second argument to the script
  * `/arg3=`_file_{:title="Path of a file (or a directory)"}: Third argument to the script
  * `/arg4=`_file_{:title="Path of a file (or a directory)"}: Fourth argument to the script
  * `/arg5=`_file_{:title="Path of a file (or a directory)"}: Fifth argument to the script
  * `/arg6=`_file_{:title="Path of a file (or a directory)"}: Sixth argument to the script
  * `/range-type=`_choice_{:title="One of: lin, log"}: If one, transform arguments into ranged numbers
  * `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not display is updated during the load
  * `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the commands run are added to the history (defaults to false)

{::comment} synopsis-end: run-for-each {:/}
{::comment} description-start: run-for-each {:/}
Runs the given script file successively for each argument given. For
instance, running:

~~~
QSoas> run-for-each process-my-file.cmds file1 file2 file3
~~~

Is equivalent to running successively

~~~
QSoas> @ process-my-file.cmds file1 
QSoas> @ process-my-file.cmds file2
QSoas> @ process-my-file.cmds file3
~~~

The arguments may not be file names, although automatic completion
will only complete file names. If the script you want to run requires
more than one argument, you can specify them (for all the runs) using
the options `/arg2`, `/arg3` and so on:

~~~
QSoas> run-for-each process-my-file.cmds /arg2=other file1 file2 
~~~

Is equivalent to running:

~~~
QSoas> @ process-my-file.cmds file1 other
QSoas> @ process-my-file.cmds file2 other
~~~

{::comment} description-end: run-for-each {:/}
{::comment} synopsis-start: run-for-datasets {:/}

### run-for-datasets - Runs a script for several datasets {#cmd-run-for-datasets}

`run-for-datasets` _script_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/arg1=`_file_{:title="Path of a file (or a directory)"} `/arg2=`_file_{:title="Path of a file (or a directory)"} `/arg3=`_file_{:title="Path of a file (or a directory)"} `/arg4=`_file_{:title="Path of a file (or a directory)"} `/arg5=`_file_{:title="Path of a file (or a directory)"} `/arg6=`_file_{:title="Path of a file (or a directory)"}

  * _script_{:title="Path of a file (or a directory)"}: The script file
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: All the arguments for the script file to loop on
  * `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not display is updated during the load
  * `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the commands run are added to the history (defaults to false)
  * `/arg1=`_file_{:title="Path of a file (or a directory)"}: First argument to the script
  * `/arg2=`_file_{:title="Path of a file (or a directory)"}: Second argument to the script
  * `/arg3=`_file_{:title="Path of a file (or a directory)"}: Third argument to the script
  * `/arg4=`_file_{:title="Path of a file (or a directory)"}: Fourth argument to the script
  * `/arg5=`_file_{:title="Path of a file (or a directory)"}: Fifth argument to the script
  * `/arg6=`_file_{:title="Path of a file (or a directory)"}: Sixth argument to the script

{::comment} synopsis-end: run-for-datasets {:/}
{::comment} description-start: run-for-datasets {:/}
Runs the given script file for each of the datasets given. Before each
invocation of the script, the dataset is pushed back to the top of the
stack, as if by [cmd: fetch].
{::comment} description-end: run-for-datasets {:/}
{::comment} synopsis-start: noop {:/}

### noop - No op {#cmd-noop}

`noop` _ignored..._ `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _ignored..._: Ignored arguments
  * `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Ignored options

{::comment} synopsis-end: noop {:/}
{::comment} description-start: noop {:/}
Does not do anything, but slurps all arguments and options given.
{::comment} description-end: noop {:/}


## Non-interactive commands {#non-interactive}

In addition to purely scripting commands, many commands do not require
user interaction, provided all their arguments are given. They are
listed here:

{::comment} non-interactive-start {:/}

 * [`1`](#cmd-1)
 * [`2`](#cmd-2)
 * [`apply-formula`](#cmd-apply-formula)
 * [`auto-correlation`](#cmd-auto-correlation)
 * [`auto-filter-bs`](#cmd-auto-filter-bs)
 * [`auto-filter-fft`](#cmd-auto-filter-fft)
 * [`average`](#cmd-average)
 * [`bin`](#cmd-bin)
 * [`break`](#cmd-break)
 * [`browse`](#cmd-browse)
 * [`cat`](#cmd-cat)
 * [`cd`](#cmd-cd)
 * [`chop`](#cmd-chop)
 * [`clear`](#cmd-clear)
 * [`clear-stack`](#cmd-clear-stack)
 * [`combine-fits`](#cmd-combine-fits)
 * [`commands`](#cmd-commands)
 * [`comment`](#cmd-comment)
 * [`contract`](#cmd-contract)
 * [`credits`](#cmd-credits)
 * [`custom-fit`](#cmd-custom-fit)
 * [`dataset-options`](#cmd-dataset-options)
 * [`define-alias`](#cmd-define-alias)
 * [`define-derived-fit`](#cmd-define-derived-fit)
 * [`define-kinetic-system-fit`](#cmd-define-kinetic-system-fit)
 * [`diff`](#cmd-diff)
 * [`diff2`](#cmd-diff2)
 * [`display-aliases`](#cmd-display-aliases)
 * [`div`](#cmd-div)
 * [`downsample`](#cmd-downsample)
 * [`drop`](#cmd-drop)
 * [`dx`](#cmd-dx)
 * [`dy`](#cmd-dy)
 * [`echem-peaks`](#cmd-echem-peaks)
 * [`edit`](#cmd-edit)
 * [`eval`](#cmd-eval)
 * [`expand`](#cmd-expand)
 * [`fetch`](#cmd-fetch)
 * [`find-peaks`](#cmd-find-peaks)
 * [`find-root`](#cmd-find-root)
 * [`find-steps`](#cmd-find-steps)
 * [`flag`](#cmd-flag)
 * [`generate-buffer`](#cmd-generate-buffer)
 * [`graphics-settings`](#cmd-graphics-settings)
 * [`help`](#cmd-help)
 * [`integrate`](#cmd-integrate)
 * [`interpolate`](#cmd-interpolate)
 * [`kinetic-system`](#cmd-kinetic-system)
 * [`load`](#cmd-load)
 * [`load-as-csv`](#cmd-load-as-csv)
 * [`load-as-text`](#cmd-load-as-text)
 * [`load-documentation`](#cmd-load-documentation)
 * [`load-fits`](#cmd-load-fits)
 * [`load-stack`](#cmd-load-stack)
 * [`merge`](#cmd-merge)
 * [`noop`](#cmd-noop)
 * [`norm`](#cmd-norm)
 * [`ode`](#cmd-ode)
 * [`output`](#cmd-output)
 * [`overlay`](#cmd-overlay)
 * [`overlay-buffer`](#cmd-overlay-buffer)
 * [`points`](#cmd-points)
 * [`print`](#cmd-print)
 * [`pwd`](#cmd-pwd)
 * [`quit`](#cmd-quit)
 * [`redo`](#cmd-redo)
 * [`remove-spikes`](#cmd-remove-spikes)
 * [`rename`](#cmd-rename)
 * [`ruby-run`](#cmd-ruby-run)
 * [`run`](#cmd-run)
 * [`run-for-datasets`](#cmd-run-for-datasets)
 * [`run-for-each`](#cmd-run-for-each)
 * [`save`](#cmd-save)
 * [`save-buffers`](#cmd-save-buffers)
 * [`save-history`](#cmd-save-history)
 * [`save-output`](#cmd-save-output)
 * [`save-stack`](#cmd-save-stack)
 * [`segments-chop`](#cmd-segments-chop)
 * [`set-meta`](#cmd-set-meta)
 * [`set-perp`](#cmd-set-perp)
 * [`shiftx`](#cmd-shiftx)
 * [`show`](#cmd-show)
 * [`show-stack`](#cmd-show-stack)
 * [`sim-adsorbed`](#cmd-sim-adsorbed)
 * [`sim-ecr-wave`](#cmd-sim-ecr-wave)
 * [`sim-eecr-relay-wave`](#cmd-sim-eecr-relay-wave)
 * [`sim-eecr-wave`](#cmd-sim-eecr-wave)
 * [`sim-exponential-decay`](#cmd-sim-exponential-decay)
 * [`sim-gaussian`](#cmd-sim-gaussian)
 * [`sim-kinetic-system`](#cmd-sim-kinetic-system)
 * [`sim-lorentzian`](#cmd-sim-lorentzian)
 * [`sim-multiexp-multistep`](#cmd-sim-multiexp-multistep)
 * [`sim-nernst`](#cmd-sim-nernst)
 * [`sim-polynomial`](#cmd-sim-polynomial)
 * [`sim-slow-scan-hp`](#cmd-sim-slow-scan-hp)
 * [`sim-slow-scan-lp`](#cmd-sim-slow-scan-lp)
 * [`sim-two-polynomials`](#cmd-sim-two-polynomials)
 * [`sort`](#cmd-sort)
 * [`split-monotonic`](#cmd-split-monotonic)
 * [`splita`](#cmd-splita)
 * [`splitb`](#cmd-splitb)
 * [`startup-files`](#cmd-startup-files)
 * [`stats`](#cmd-stats)
 * [`strip-if`](#cmd-strip-if)
 * [`subtract`](#cmd-subtract)
 * [`temperature`](#cmd-temperature)
 * [`tex-commands`](#cmd-tex-commands)
 * [`transpose`](#cmd-transpose)
 * [`tweak-columns`](#cmd-tweak-columns)
 * [`undo`](#cmd-undo)
 * [`unflag`](#cmd-unflag)
 * [`unwrap`](#cmd-unwrap)
 * [`update-documentation`](#cmd-update-documentation)
 * [`zero`](#cmd-zero)
{::comment} non-interacive-end {:/}


## Ruby code {#ruby}

QSoas internally uses [Ruby][ruby] for the interpretation of all
formulas. This means in particular that all formulas must be valid
ruby code.

Basically, the [Ruby][ruby] syntax ressembles that of other symbolic
evaluation programs (it is quite close to the one from
[gnuplot][gnuplot]), with the following restrictions: 

 * Parameter names **cannot start with an uppercase letter**, as those have a
   special meaning to the Ruby interpreter: anything that starts with
   an uppercase letter is assumed to be a constant.
 * Don't abbreviate floating points: `2.` and `.4` are invalid, use
   `2.0` and `0.4` instead.
 * Case matters: `Pi` is $$\pi$$, while `pi` is nothing defined.

In addition to standard mathematical functions from the [Math][math]
module, the following special functions are available:

{::comment} special-functions-start {:/}

 * `atanc`: $$\frac{\tan^{-1} x}{x}$$
 * `atanhc`: $$\frac{\tanh^{-1} x}{x}$$
 * `bessel_j0`: Regular cylindrical Bessel function of 0th order, $$J_0(x)$$
 * `bessel_j1`: Regular cylindrical Bessel function of first order, $$J_1(x)$$
 * `bessel_jn`: Regular cylindrical Bessel function of n-th order, $$J_n(x)$$
 * `expint_e1`: Exponential integral $$E_1(x) = \int_{x}^{\infty} \frac{\exp -t}{t} \mathrm{d} t$$
 * `expint_e2`: Exponential integral $$E_2(x) = \int_{x}^{\infty} \frac{\exp -t}{t^2} \mathrm{d} t$$
 * `expint_en`: Exponential integral $$E_n(x) = \int_{x}^{\infty} \frac{\exp -t}{t^n} \mathrm{d} t$$

{::comment} special-functions-end {:/}

Some physical/mathematical constants are available; their name starts
with an **uppercase** letter.

{::comment} constants-start {:/}

 * `C`: The speed of light in vacuum, $$c$$ -- 2.99792e+08
 * `Eps_0`: The permeability of vacuum, $$\epsilon_0$$ -- 1.25664e-06
 * `F`: Faraday's constant, $$F$$ -- 96485.3
 * `H`: The Planck constant, $$h$$ -- 6.62607e-34
 * `Hbar`: $$\hbar = h/2\pi$$ -- 1.05457e-34
 * `Kb`: Boltzmann's constant -- 1.38065e-23
 * `Mu_0`: The permittivity of vacuum, $$\mu_0$$ -- 8.85419e-12
 * `Na`: The Avogadro number, $$N_A$$ -- 6.02214e+23
 * `Pi`, `PI`: $$\pi$$ -- 3.14159
 * `R`: Molar gas constant, $$R$$ -- 8.31447
 * `Sigma`: The Stefan-Boltzmann radiation constant -- 5.6704e-08

{::comment} constants-end {:/}


[ruby]:http://www.ruby-lang.org/ "Ruby, the programming language"
[math]:http://www.ruby-doc.org/core-1.9.3/Math.html "Documentation of the Math module"
[gnuplot]:http://www.gnuplot.info/ "Gnuplot, the plotting program"

