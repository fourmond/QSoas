**Important warning**
Some commands of `QSoas` may not be documented here. It means they are
supported in no way: their syntax may change without notice, they may
disappear, they may turn out to do completely different things in the
end. In short, **use them at your own risks** (and it would be a good
idea to check out the code, in that case).


# Commands, arguments and options (how to read this document)

QSoas works by entering commands inside the command prompt.

Most commands have arguments and options. Arguments and options are
separated by spaces:

~~~ 
QSoas> command argument1 argument2 "argument 3" /option=option /option2="with spaces"
~~~

If you need to pass arguments or option values that have spaces, make
sure you quote them using `"` or `'`, like in the above example.

Arguments are indicated like _that_ in the documentation below. You
need to provide all the arguments for a command to work. Some
arguments are followed by _..._, which means that you can pass several
space-separated arguments. This is the case for [`load`](#cmd-load),
for instance:

~~~
QSoas> load file1 file2 file3
~~~

Some options are marked as "(default)", which means that, if all
arguments of the command are already specified, you can omit the
`/option=` part of the option. For instance, to set the
[`temperature`](#cmd-temperature) to 300 K, you should be doing that:

~~~
QSoas> temperature /set=300
~~~

But, as `/set` is the default option, you can omit the `/set=`
altogether and write:

~~~
QSoas> temperature 300
~~~

In this documentation, all options and arguments have mouseover texts
that give a short explanation of what kind of values are expected.


# General

Here are the commands to interact with QSoas in the most general way:
exit, change directory, change various global parameters.


{::comment} synopsis-start: quit {:/}

### quit - Quit {#cmd-quit}

`quit` 

Alias: `q`


{::comment} synopsis-end: quit {:/}
{::comment} description-start: quit {:/}
Exits QSoas, losing all the current session. Keep in mind, though,
that the full log of the session is always available in the
`soas.log` file created in the initial directory, which is indicated in
the very beginning in the terminal.
{::comment} description-end: quit {:/}


{::comment} synopsis-start: credits {:/}

### credits - Credits {#cmd-credits}

`credits` 


{::comment} synopsis-end: credits {:/}
{::comment} description-start: credits {:/}

This command displays credits, copyright and license information of 
QSoas and all the dependencies linked to or built in your version.

It also lists publications whose findings/equations/algorithms were
directly used in QSoas.
{::comment} description-end: credits {:/}


{::comment} synopsis-start: save-history {:/}

### save-history - Save history {#cmd-save-history}

`save-history` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Output file

{::comment} synopsis-end: save-history {:/}
{::comment} description-start: save-history {:/}
Saves all the commands contained in the history, that is all the
commands that were launched from the beginning of the session, to the
given (text) file.

This can be used for saving a series of command that should be applied
repetitively as a [script](#scripting).
{::comment} description-end: save-history {:/}

{::comment} synopsis-start: cd {:/}

### cd - Change directory {#cmd-cd}

`cd` _directory_{:title="Path of a file (or a directory)"} `/from-home=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/from-script=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `G`

  * _directory_{:title="Path of a file (or a directory)"}: New directory
  * `/from-home=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, relative from the home directory
  * `/from-script=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, cd relative from the current script directory

{::comment} synopsis-end: cd {:/}
{::comment} description-start: cd {:/}
Changes the current working directory. If `/from-home` is specified,
the directory is assumed to be relative to the user's home directory. 
If `/from-script` is specified, the directory is assumed to be
relative to that of the command file currently being executed by a 
[`run`](#cmd-run) command (or in a [startup script](#cmd-startup-files)).



As of now, it doesn't change the output files and the log files, but
it eventually will.
{::comment} description-end: cd {:/}
{::comment} synopsis-start: pwd {:/}

### pwd - Working directory {#cmd-pwd}

`pwd` 


{::comment} synopsis-end: pwd {:/}
{::comment} description-start: pwd {:/}
Prints the full path of the current directory.

It is also the one indicated in the title of the QSoas window.
{::comment} description-end: pwd {:/}

{::comment} synopsis-start: temperature {:/}

### temperature - Temperature {#cmd-temperature}

`temperature` `/set=`_number_{:title="A floating-point number"}

Alias: `T`

  * `/set=`_number_{:title="A floating-point number"} (default): Sets the temperature

{::comment} synopsis-end: temperature {:/}
{::comment} description-start: temperature {:/}
Shows or sets the current temperature. The temperature is used in many
places, mostly in fits to serve as the initial value for the
temperature parameter. To set the temperature, pass its new value as
the `/set` option (the `/set=` part is optional):

~~~
QSoas> temperature 310
~~~

{::comment} description-end: temperature {:/}

{::comment} synopsis-start: commands {:/}

### commands - Commands {#cmd-commands}

`commands` 


{::comment} synopsis-end: commands {:/}
{::comment} description-start: commands {:/}
List all available commands, with a short help text. This also
includes used-defined commands, such as custom fits loaded from a fit file.
{::comment} description-end: commands {:/}
{::comment} synopsis-start: help {:/}

### help - Help on... {#cmd-help}

`help` _command_{:title="The name of one of QSoas's commands"} `/online=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `?`

  * _command_{:title="The name of one of QSoas's commands"}: The command on which to give help
  * `/online=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} (default): Show the online documentation in a browser

{::comment} synopsis-end: help {:/}
{::comment} description-start: help {:/}
Gives all help available on the given command. By default, it fires up
a browser to show the online help, unless you use `/online=false`.
{::comment} description-end: help {:/}

{::comment} synopsis-start: save-output {:/}

### save-output - Save output {#cmd-save-output}

`save-output` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Output file

{::comment} synopsis-end: save-output {:/}
{::comment} description-start: save-output {:/}
Save all text in the terminal to a plain text file.

Equivalent to copy-pasting the contents of the terminal to a plain
text file using a text editor.
{::comment} description-end: save-output {:/}


{::comment} synopsis-start: print {:/}

### print - Print {#cmd-print}

`print` `/file=`_file_{:title="Path of a file (or a directory)"} `/title=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `p`

  * `/file=`_file_{:title="Path of a file (or a directory)"}: Save as file
  * `/title=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Sets the title of the page as printed

{::comment} synopsis-end: print {:/}
{::comment} description-start: print {:/}
Prints the current view, providing a usual print dialog. If you just
want a PDF or PostScript file, just provide the file name as the
`/file` option.

An optional title can be added using the `/title` option.

**Important note** please keep in mind that QSoas is not designed to
be a data plotting system, it is a data analysis system. So plotting
capacities don't go far...
{::comment} description-end: print {:/}


{::comment} synopsis-start: define-alias {:/}

### define-alias - Define alias {#cmd-define-alias}

`define-alias` _alias_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _command_{:title="The name of one of QSoas's commands"} `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _alias_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The name to give to the new alias
  * _command_{:title="The name of one of QSoas's commands"}: The command to give an alias for
  * `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): All options

{::comment} synopsis-end: define-alias {:/}
{::comment} description-start: define-alias {:/}
The `define-alias` commands allows one to defined a shortcut for a
command one uses often with the same options. For instance, running:

~~~~
QSoas> define-alias fit-2exp fit-exponential-decay /exponentials=2 /loss=true
~~~~

creates a `fit-2exp` command that is equivalent to starting 
[`fit-exponential-decay`](#cmd-fit-exponential-decay) with two
exponentials by default and film loss on. 

While it is possible to define "default options" for aliased commands
this way, there is no way to add arguments: you must still go on
specifying all the arguments to the alias.
{::comment} description-end: define-alias {:/}

{::comment} synopsis-start: display-aliases {:/}

### display-aliases - Display aliases {#cmd-display-aliases}

`display-aliases` 


{::comment} synopsis-end: display-aliases {:/}
{::comment} description-start: display-aliases {:/}
Shows a list of all the currently defined aliases.
{::comment} description-end: display-aliases {:/}

{::comment} synopsis-start: graphics-settings {:/}

### graphics-settings - Graphics settings {#cmd-graphics-settings}

`graphics-settings` `/line-width=`_number_{:title="A floating-point number"} `/opengl=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/antialias=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/line-width=`_number_{:title="A floating-point number"}: Sets the base line width for all lines/curves
  * `/opengl=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turns on/off the use of OpenGL acceleration
  * `/antialias=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turns on/off the use of antialised graphics

{::comment} synopsis-end: graphics-settings {:/}
{::comment} description-start: graphics-settings {:/}
Gives the possibility to tweak a few settings concerning display.

The settings are persistent and kept from one QSoas session until the
next one.

Turning on antialias will make QSoas use antialiased drawings, which
looks admittedly nicer, but requires much more computational
time. Printing or exporting to PDF files through [`print`](#cmd-print)
always produces antialiased graphics, regardless of this option.

If you experience performance problems for displaying curves, use
`/opengl=true`, as this will instruct QSoas to use hardware
acceleration to display curves, which should greatly enhance the
display speed. It is off by default as some setups do not really
benefit from that.
{::comment} description-end: graphics-settings {:/}


{::comment} synopsis-start: ruby-run {:/}

### ruby-run - Ruby load {#cmd-ruby-run}

`ruby-run` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: Ruby file to load

{::comment} synopsis-end: ruby-run {:/}
{::comment} description-start: ruby-run {:/}
This command loads and executes a Ruby file. For the time being, the
main interest of this command is to define complex functions in a
separate file. 

Imagine you have a file `function.rb` containing the text:

~~~~
def function(x,a)
  return x**(a**x)
end
~~~~

After running 

~~~~
QSoas> ruby-run function.rb
~~~~

You can use `function` like any normal function for fitting:

~~~~
QSoas> fit-arb 'function(x,a)'
~~~~
{::comment} description-end: ruby-run {:/}

{::comment} synopsis-start: break {:/}

### break - Break {#cmd-break}

`break` 


{::comment} synopsis-end: break {:/}
{::comment} description-start: break {:/}
Exits from the current script. 

Has no effect if not within a script.
{::comment} description-end: break {:/}



## Output file manipulation

Several commands (e.g.  various data analysis commands and the fit
commands) write data to the output file.

By default, the first time the output file is used, a `output.dat`
file is created in the current directory. Another file can be used by
providing its name to the [`output`](#cmd-output) command.

{::comment} synopsis-start: output {:/}

### output - Change output file {#cmd-output}

`output` _file_{:title="Path of a file (or a directory)"} `/truncate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _file_{:title="Path of a file (or a directory)"}: Name of the new output file
  * `/truncate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, removes all the contents of the target before opening

{::comment} synopsis-end: output {:/}
{::comment} description-start: output {:/}
Opens _file_ as the new output file. By default, if the file exists,
new data are appended, and the old data are left untouched. You can
force overwriting by specifiying `/truncate=true`.
{::comment} description-end: output {:/}

{::comment} synopsis-start: comment {:/}

### comment - Write line to output {#cmd-comment}

`comment` _comment_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _comment_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Comment line added to output file

{::comment} synopsis-end: comment {:/}
{::comment} description-start: comment {:/}
Writes the given line _comment_ to the output file.
{::comment} description-end: comment {:/}




# Data loading/saving

The main command for loading data is [`load`](#cmd-load)

{::comment} synopsis-start: load {:/}

### load - Load {#cmd-load}

`load` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/style=`_style_{:title="One of: red-blue"} `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `l`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, ignores what is in the cache
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines

{::comment} synopsis-end: load {:/}
{::comment} description-start: load {:/}

Loads the given files and push them onto the data stack. QSoas
features several backends for loading files (``backends'' are roughly
equivalent to ``file formats''). In principle, QSoas is
smart enough to figure out which one is the correct one, but you can
force a given backend by using the appropriate `load-as-`
command. Using a backend directly also provides more control on the
way files are loaded (this can also be done via the numerous options
to `load`, which are forwarded to the appropriate backend). Currently
available backends:

 * [`text`](#cmd-load-as-text) for plain space-separated text
 * [`csv`](#cmd-load-as-csv) for CSV data

Look in their documentation for more information. QSoas tells you
which backend it used for loading a given file:

~~~~
QSoas> load 03.dat
Loading file: './03.dat' using backend text
~~~~

The command `load` caches the loaded file. If for some reason, the
cache gets in the way, use the direct `load-as-` commands, or
alternatively use `/ignore-cache=true`.

`load`, together with all the other commands that take several files
as arguments understand unix-like wildcards:

~~~~
QSoas> load *.dat
~~~~

This command loads all the `.dat` files from the current directory.

~~~~
QSoas> load [0-4]*.dat
~~~~

This loads only those that start with a digit from 0 to 4, etc.

The `load` command and the corresponding `load-as-` command makes it
possible to set dataset options just as with the 
[`dataset-options`](#cmd-dataset-options).

The style option sets the color style when loading several curves:

~~~~
QSoas> load *.dat /style=red-blue
~~~~

This loads all the `.dat` files in the current directory, and displays
them with a color gradient from red (for the first loaded file) to
blue (for the last loaded file). This makes it very easy to follow
subtle modifications from one data file to the next.


{::comment} description-end: load {:/}


{::comment} synopsis-start: load-as-text {:/}

### load-as-text - Load files with backend 'text' {#cmd-load-as-text}

`load-as-text` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"}

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display

{::comment} synopsis-end: load-as-text {:/}
{::comment} description-start: load-as-text {:/}

Load any number of files using the backend `text`, bypassing cache and
automatic backend detection. `text` recognises space-separated data
(which includes tab-separated data). Most "plain text" files will give
good results. By default, it loads all the columns of the file, but
only displays the second as a function of the first. If you want to
work on other columns, have a look at [`expand`](#cmd-expand).

Apart from the options of [`dataset-options`](#cmd-dataset-options)
and the `/style` documented above, the `text` backend accepts several
options controlling the way the text files are interpreted:

  * `/separator` is the text that separate the columns (blank space by
    default. You can use [Qt regular
    expressions](http://qt-project.org/doc/qt-4.8/qregexp.html#introduction)
    enclosed by `/`, such as: `/[;,]/` to split columns on semicolon
    or commas.
  * `/decimal` is the decimal separator (default is the dot).
  * `/comments` is a regular expression describing comment lines (ie
    lines that get ignored). By default, any line that doesn't start
    by a number is ignored.
  * If `/auto-split` is `true`, then `QSoas` will create a new dataset
    everytime it hits a series of blank lines in the file.
  * `/columns` is a series of numbers saying in which order the file
    columns will be used to make a dataset. For instance,
    `/columns=2,1` will swap X and Y at load time.


{::comment} description-end: load-as-text {:/}


{::comment} synopsis-start: load-as-csv {:/}

### load-as-csv - Load files with backend 'csv' {#cmd-load-as-csv}

`load-as-csv` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/style=`_style_{:title="One of: red-blue"}

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display

{::comment} synopsis-end: load-as-csv {:/}
{::comment} description-start: load-as-csv {:/}
The `csv` backend is essentially the same backend as the
[`text`](#cmd-load-as-text) one, but with the separators set by
default to commas and semicolons, to parse CSV files. 
Hence, the options have the same
meaning as for [`load-as-text`](#cmd-load-as-text).
{::comment} description-end: load-as-csv {:/}


{::comment} synopsis-start: expand {:/}

### expand - Expand {#cmd-expand}

`expand` 


{::comment} synopsis-end: expand {:/}
{::comment} description-start: expand {:/}
If a buffer contains several columns, QSoas only displays the second as a
function of the first.  expand splits the current buffer into as many
buffers as there are Y columns, ie a X, Y1, Y2, Y3 buffer will be split
into three buffers: X, Y1;   X, Y2 and  X, Y3.
{::comment} description-end: expand {:/}

{::comment} synopsis-start: rename {:/}

### rename - Rename {#cmd-rename}

`rename` _new-name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `a`

  * _new-name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: New name 

{::comment} synopsis-end: rename {:/}
{::comment} description-start: rename {:/}
Changes the current name of the buffer. To help track the
operations applied to a buffer, its name is modified and gets
longer after each modification. `rename` can be used to change
that to give it a more meaningful (and less long) name .
{::comment} description-end: rename {:/}

{::comment} synopsis-start: save {:/}

### save - Save {#cmd-save}

`save` _file_{:title="Path of a file (or a directory)"} `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/mkpath=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `s`

  * _file_{:title="Path of a file (or a directory)"}: File name for saving
  * `/overwrite=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, overwrite without prompting
  * `/mkpath=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If true, creates all necessary directories

{::comment} synopsis-end: save {:/}
{::comment} description-start: save {:/}
Saves the current buffer to a file.
{::comment} description-end: save {:/}

{::comment} synopsis-start: save-buffers {:/}

### save-buffers - Save {#cmd-save-buffers}

`save-buffers` _buffers..._{:title="Comma-separated lists of datasets in the stack"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to save

{::comment} synopsis-end: save-buffers {:/}
{::comment} description-start: save-buffers {:/}
Saves the designated buffers to file.

Unlike the [`save`](#cmd-save) command, this saves the buffers using
their current name, and does not prompt for a file name. It is
probably a good idea to use [`rename`](#cmd-rename) first.
{::comment} description-end: save-buffers {:/}

{::comment} synopsis-start: browse {:/}

### browse - Browse files {#cmd-browse}

`browse` `/pattern=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

Alias: `W`

  * `/pattern=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Files to browse

{::comment} synopsis-end: browse {:/}
{::comment} description-start: browse {:/}
Browse all datafiles in the current directory (or those matching the
wildcard pattern given to `/pattern`, see [`load`](#cmd-load) for more
information about wildcards). Very useful to find quickly the file
you're looking for.
{::comment} description-end: browse {:/}


# Data display

{::comment} synopsis-start: overlay-buffer {:/}

### overlay-buffer - Overlay buffers {#cmd-overlay-buffer}

`overlay-buffer` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/style=`_style_{:title="One of: red-blue"}

Alias: `V`

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to overlay
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display

{::comment} synopsis-end: overlay-buffer {:/}
{::comment} description-start: overlay-buffer {:/}
Plots one or several buffers on top of the current buffer.

See [`load`](#cmd-load) for the description of the `/style` option.
{::comment} description-end: overlay-buffer {:/}

{::comment} synopsis-start: overlay {:/}

### overlay - Overlay {#cmd-overlay}

`overlay` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/style=`_style_{:title="One of: red-blue"} `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"} `/columns=`_integers_{:title="A comma-separated list of integers"} `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `v`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: Files to load !
  * `/style=`_style_{:title="One of: red-blue"}: Style for curves display
  * `/ignore-cache=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, ignores what is in the cache
  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram
  * `/separator=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Separator between columns
  * `/decimal=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Decimal separator
  * `/comments=`_pattern_{:title="Text, or Qt regular expression enclosed within / / delimiters"}: Comment lines
  * `/columns=`_integers_{:title="A comma-separated list of integers"}: Order of the columns
  * `/auto-split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Split on blank lines

{::comment} synopsis-end: overlay {:/}
{::comment} description-start: overlay {:/}
This command combines [`overlay-buffer`](#cmd-overlay-buffer) and 
[`load`](#cmd-load) in one go: loads the files given as arguments and
adds them to the current plot.
{::comment} description-end: overlay {:/}

{::comment} synopsis-start: clear {:/}

### clear - Clear view {#cmd-clear}

`clear` 


{::comment} synopsis-end: clear {:/}
{::comment} description-start: clear {:/}
Removes all datasets except the current buffer from the display. Use to
revert the effect of a previous overlay command, or can be useful if
for some reason a command failed while not restoring the display (but
that really should not happen anyway).
{::comment} description-end: clear {:/}

{::comment} synopsis-start: points {:/}

### points - Show points {#cmd-points}

`points` 

Alias: `poi`


{::comment} synopsis-end: points {:/}
{::comment} description-start: points {:/}
Shows datapoints (by default, datasets are plotted by connecting
datapoints with a line).

Use this with parcimony, as for large datasets, it can significantly
slow down the display.
{::comment} description-end: points {:/}

{::comment} synopsis-start: zoom {:/}

### zoom - Zoom {#cmd-zoom}

`zoom` **(interactive)**

Alias: `z`


{::comment} synopsis-end: zoom {:/}
{::comment} description-start: zoom {:/}
Zooms on the current curve. 

While zooming is already possible to zoom using the mouse wheel, with
this command one draws a rectangle with the mouse around the region of
interest.

{::comment} description-end: zoom {:/}




# Data stack manipulation

Data files are loaded and manipulated in a stack. Every time a file is
loaded or a buffer modified, the new buffer is pushed onto the top of
the stack, and becomes the current buffer (numbered 0). Older buffers
have increasing numbers (the previous buffer is 1, the one before 2,
and so on). There is also a "redo" stack populated by the
[`undo`](#cmd-undo) command. Stack can be manipulated in different
ways:

 * the current buffer can be changed using
   [`undo`](#cmd-undo)/[`redo`](#cmd-redo);
 * buffers can be permanently removed from the stack using
   [`drop`](#cmd-drop);
 * the whole stack can be saved for later use with
   [`save-stack`](#cmd-save-stack) and restored using
   [`load-stack`](#cmd-load-stack), or dropped altogether using
   [`clear-stack`](#cmd-clear-stack);
 * contents of the stack can be displayed in the terminal using
   [`show-stack`](#cmd-show-stack) or in a dialog bog with 
   [`browse-stack`](#cmd-browse-stack).
 * an old buffer can be put back on the top of the stack with
   [`fetch`](#cmd-fetch).
 * buffers can be flagged ([`flag`](#cmd-flag)) or unflagged
   ([`unflag`](#cmd-unflag)) to be used later using the `flagged`
   buffer selector.


{::comment} synopsis-start: browse-stack {:/}

### browse-stack - Browse stack {#cmd-browse-stack}

`browse-stack` **(interactive)**

Alias: `K`


{::comment} synopsis-end: browse-stack {:/}
{::comment} description-start: browse-stack {:/}
Displays a dialog box to show the current contents of the stack.
{::comment} description-end: browse-stack {:/}

{::comment} synopsis-start: show-stack {:/}

### show-stack - Show stack {#cmd-show-stack}

`show-stack` `/number=`_integer_{:title="An integer"}

Alias: `k`

  * `/number=`_integer_{:title="An integer"} (default): Limit the display to a given number

{::comment} synopsis-end: show-stack {:/}
{::comment} description-start: show-stack {:/}
Shows a small summary of what the stack is made of
{::comment} description-end: show-stack {:/}


{::comment} synopsis-start: redo {:/}

### redo - Redo {#cmd-redo}

`redo` `/number=`_integer_{:title="An integer"}

Alias: `r`

  * `/number=`_integer_{:title="An integer"} (default): Number of operations to undo

{::comment} synopsis-end: redo {:/}
{::comment} description-start: redo {:/}
Pops the last buffer from the redo stack and set it as the current buffer
{::comment} description-end: redo {:/}

{::comment} synopsis-start: undo {:/}

### undo - Undo {#cmd-undo}

`undo` `/number=`_integer_{:title="An integer"}

Alias: `u`

  * `/number=`_integer_{:title="An integer"} (default): Number of operations to undo

{::comment} synopsis-end: undo {:/}
{::comment} description-start: undo {:/}
Returns to the previous buffer, and push the current to the redo stack
{::comment} description-end: undo {:/}

{::comment} synopsis-start: load-stack {:/}

### load-stack - Load stack {#cmd-load-stack}

`load-stack` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File name for saving stack

{::comment} synopsis-end: load-stack {:/}
{::comment} description-start: load-stack {:/}
Loads the stack as saved using save-stack
{::comment} description-end: load-stack {:/}

{::comment} synopsis-start: save-stack {:/}

### save-stack - Save stack {#cmd-save-stack}

`save-stack` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File name for saving stack

{::comment} synopsis-end: save-stack {:/}
{::comment} description-start: save-stack {:/}
Saves the contents of the stack for later use, in a private binary format
{::comment} description-end: save-stack {:/}


{::comment} synopsis-start: clear-stack {:/}

### clear-stack - Clear stack {#cmd-clear-stack}

`clear-stack` 

Alias: `delstack`


{::comment} synopsis-end: clear-stack {:/}
{::comment} description-start: clear-stack {:/}
Removes all the buffers from both normal and redo stack
{::comment} description-end: clear-stack {:/}

{::comment} synopsis-start: fetch {:/}

### fetch - Fetch an old buffer {#cmd-fetch}

`fetch` _buffers..._{:title="Comma-separated lists of datasets in the stack"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers to fetch

{::comment} synopsis-end: fetch {:/}
{::comment} description-start: fetch {:/}
Put back a *copy* of the given buffer on the top of the stack. Useful
when you want to work again on a old buffer buried in the stack.
{::comment} description-end: fetch {:/}

{::comment} synopsis-start: drop {:/}

### drop - Drop dataset {#cmd-drop}

`drop` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"}

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to drop

{::comment} synopsis-end: drop {:/}
{::comment} description-start: drop {:/}
Permanently deletes the current dataset (or the ones specified in the
`/buffers` options) from the stack.

~~~~
QSoas> drop 3..16
~~~~ 

drops all the buffers from 3 to 16 included. 

*Important:* it is *not* possible to recover a buffer once it has been
dropped from the stack. [`undo`](#cmd-undo) won't work. Use it only on
buffers you're sure you won't need again (such as computation intermediates). 
{::comment} description-end: drop {:/}
{::comment} synopsis-start: flag {:/}

### flag - Flag datasets {#cmd-flag}

`flag` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"}

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to flag/unflag

{::comment} synopsis-end: flag {:/}
{::comment} description-start: flag {:/}
Flags the given buffer (or the current one if none is supplied) for
later use. All currently flagged buffers can be specified using the
`flagged` argument to, for instance,
[`overlay-buffer`](#cmd-overlay-buffer).
{::comment} description-end: flag {:/}
{::comment} synopsis-start: unflag {:/}

### unflag - Unflag datasets {#cmd-unflag}

`unflag` `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"}

  * `/buffers=`_buffers_{:title="Comma-separated lists of datasets in the stack"} (default): Buffers to flag/unflag

{::comment} synopsis-end: unflag {:/}
{::comment} description-start: unflag {:/}
Removes the flag on the given datasets.
{::comment} description-end: unflag {:/}



# Basic data manipulation at the buffer level

{::comment} synopsis-start: apply-formula {:/}

### apply-formula - Apply formula {#cmd-apply-formula}

`apply-formula` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-columns=`_integer_{:title="An integer"} `/use-stats=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `F`

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Formula (valid Ruby code)
  * `/extra-columns=`_integer_{:title="An integer"}: Number of extra columns to create
  * `/use-stats=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a $stats hash is available that contains statistics

{::comment} synopsis-end: apply-formula {:/}
{::comment} description-start: apply-formula {:/}
Applies a formula to the current dataset. It should specify how the
`x` and/or `y` values of the dataset are modified:

~~~~
QSoas> apply-formula 'x = x**2'
QSoas> apply-formula 'y = sin(x**2)'
QSoas> apply-formula 'x,y = y,x'
~~~~

The last bit swaps the X and Y values of the buffer. The formula must
be valid [ruby](#ruby) code.

In addition to `x` and `y` (note the lowercase !), the formula can
refer to: 

  * `i` (the index of the data point)
  * `y2`, `y3`, etc when there are more than 2 columns in the dataset

`i` cannot be modified, but `y2` and so on can.

Extra columns initially filled with 0 can be created by using the
`/extra-columns` option:

~~~~
QSoas> apply-formula /extra-columns=1 'y2 = y**2'
~~~~

This creates a second column containing the square of the values of
the Y column.

If `/use-stats=true` is used, a global variable `$stats` can be used
within the Ruby expression that contains all the statistics displayed
by [`stats`](#cmd-stats). For
instance, to normalize the Y values by dividing by the median, one would use:

~~~ 
QSoas> apply-formula /use-stats=true 'y = y/$stats["y_med"]'
~~~

Statistics by segments (see more about segments [there](#segments))
are available too, which means if you want to normalize by the medians
of the first segment, you could do

~~~ 
QSoas> apply-formula /use-stats=true 'y = y/$stats[0]["y_med"]'
~~~

{::comment} description-end: apply-formula {:/}


{::comment} synopsis-start: dx {:/}

### dx - DX {#cmd-dx}

`dx` 


{::comment} synopsis-end: dx {:/}
{::comment} description-start: dx {:/}
Replaces the Y values by the values of delta X, i.e, 
`y[i] = x[i+1] - x[i]`

This is useful to see if the X values are equally spaced.
{::comment} description-end: dx {:/}
{::comment} synopsis-start: dy {:/}

### dy - DY {#cmd-dy}

`dy` 


{::comment} synopsis-end: dy {:/}
{::comment} description-start: dy {:/}
Same as [`dx`](#cmd-dx) but for Y values: replaces the Y values by the
values of delta Y.
{::comment} description-end: dy {:/}

{::comment} synopsis-start: zero {:/}

### zero - Makes 0 {#cmd-zero}

`zero` _value_{:title="A floating-point number"} `/axis=`_axis_{:title="One of: x, y"}

  * _value_{:title="A floating-point number"}: 
  * `/axis=`_axis_{:title="One of: x, y"}: Which axis is zero-ed

{::comment} synopsis-end: zero {:/}
{::comment} description-start: zero {:/}
Given an X value, shifts the Y values so that the point the closest to
the given X value has 0 as Y value.

If `/axis` is `x`, swap X and Y in the above description.
{::comment} description-end: zero {:/}

{::comment} synopsis-start: shiftx {:/}

### shiftx - Shift X values {#cmd-shiftx}

`shiftx` 


{::comment} synopsis-end: shiftx {:/}
{::comment} description-start: shiftx {:/}
Shift X values so that the first point has a X value of 0.
{::comment} description-end: shiftx {:/}

{::comment} synopsis-start: norm {:/}

### norm - Normalize {#cmd-norm}

`norm` `/positive=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/map-to=`_numbers_{:title="Several numbers, separated by :"}

  * `/positive=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we normalize on positive or negative values
  * `/map-to=`_numbers_{:title="Several numbers, separated by :"} (default): Normalizes by mapping to the given segment

{::comment} synopsis-end: norm {:/}
{::comment} description-start: norm {:/}
Normalize the current buffer by its maximum value (or by the absolute
value of its most negative value if `/positive` is `false`).

If the `/map-to` option is specified, the original dataset is mapped
linearly to the given segment: 

~~~~ 
norm /map-to=2:4
~~~~

shifts and scales the original data so that the Y minimum is 2 and the
Y maximum is 4.
{::comment} description-end: norm {:/}


{::comment} synopsis-start: deldp {:/}

### deldp - Deldp {#cmd-deldp}

`deldp` **(interactive)**


{::comment} synopsis-end: deldp {:/}
{::comment} description-start: deldp {:/}
With this command, you can click on given data points to remove
them. Useful to remove a few spikes from the data. Middle click or `q`
to accept the modifications, hit escape to cancel them.
{::comment} description-end: deldp {:/}


{::comment} synopsis-start: edit {:/}

### edit - Edit dataset {#cmd-edit}

`edit` 


{::comment} synopsis-end: edit {:/}
{::comment} description-start: edit {:/}
Pops up a spreadsheet-like window where you can view and edit the
individual values of the current dataset. If you want to save your
modification, press the "push new" button.
{::comment} description-end: edit {:/}

{::comment} synopsis-start: sort {:/}

### sort - Sort {#cmd-sort}

`sort` 


{::comment} synopsis-end: sort {:/}
{::comment} description-start: sort {:/}
Sorts the buffer in increasing X values.
{::comment} description-end: sort {:/}


{::comment} synopsis-start: strip-if {:/}

### strip-if - Strip points {#cmd-strip-if}

`strip-if` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Ruby boolean expression

{::comment} synopsis-end: strip-if {:/}
{::comment} description-start: strip-if {:/}
Removes all points for which the ruby expression returns `true`. This
can be used for quite advanced data selection:

~~~~
QSoas> strip-if 'x > 2'
~~~~ 

This removes all points whose X value is over 2.

~~~~
QSoas> strip-if 'x * y < 10 && x > 2'
~~~~

This removes all the points for which both the X value is over 2 and
the product of X and Y is below 10.

When reading data files that contain spurious data points (such as
text lines containing no data within a file read with
[`load-as-text`](#cmd-load-as-text)), QSoas replaces the missing data
by weird numbers called NaN (Not a Number). They can be useful at
times, but mess up statistics and fits. To remove them, use:

~~~~
QSoas> strip-if '(x != x) || (y != y)'
~~~~


{::comment} description-end: strip-if {:/}

{::comment} synopsis-start: diff {:/}

### diff - Derive {#cmd-diff}

`diff` 


{::comment} synopsis-end: diff {:/}
{::comment} description-start: diff {:/}
Computes the 4th order accurate derivative of the buffer.

This is efficient to compute the derivative of a very smooth
function, but it gives very poor results on noisy data. In general,
for derivation, prefer [`filter-fft`](#cmd-filter-fft) or 
[`filter-bsplines`](#cmd-filter-bsplines).
{::comment} description-end: diff {:/}

{::comment} synopsis-start: diff2 {:/}

### diff2 - Derive {#cmd-diff2}

`diff2` 


{::comment} synopsis-end: diff2 {:/}
{::comment} description-start: diff2 {:/}
Computes the 4th order accurate second derivative of the buffer. 

The same warnings apply as for [`diff`](#cmd-diff).
{::comment} description-end: diff2 {:/}
{::comment} synopsis-start: dataset-options {:/}

### dataset-options - Options {#cmd-dataset-options}

`dataset-options` `/yerrors=`_integer_{:title="An integer"} `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/yerrors=`_integer_{:title="An integer"}: Column containing y errors
  * `/histogram=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Show as a histogram

{::comment} synopsis-end: dataset-options {:/}
{::comment} description-start: dataset-options {:/}
Sets options for the current dataset, such as:

 * the display of errors on Y values (you must specify the 0-based
   number of the column in the data: 0 is the X column, 1, the first Y
   column, 2 the 2nd Y column, and so on) {::comment} description-end:
   dataset-options {:/}
 * wether or not the dataset should be displayed looking like a
   histogram


## Splitting the dataset in bits (and back)

{::comment} synopsis-start: cut {:/}

### cut - Cut {#cmd-cut}

`cut` **(interactive)**

Alias: `c`


{::comment} synopsis-end: cut {:/}
{::comment} description-start: cut {:/}
Interactively cuts bits out of the buffer. Left and right mouse clicks
set the left and right limits. Middle click or q quits leaving only the
part that is within the region, while u leaves only the outer
part. Hit escape to cancel.
{::comment} description-end: cut {:/}

{::comment} synopsis-start: chop {:/}

### chop - Chop Buffer {#cmd-chop}

`chop` _lengths..._{:title="Several numbers, separated by ,"} `/mode=`_choice_{:title="One of: deltax, index, indices, xvalues"} `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _lengths..._{:title="Several numbers, separated by ,"}: Lengths of the subsets
  * `/mode=`_choice_{:title="One of: deltax, index, indices, xvalues"}: Whether to cut on index or x values (default)
  * `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to actually cut the dataset, or just to set segments where the cuts would have been

{::comment} synopsis-end: chop {:/}
{::comment} description-start: chop {:/}
Cuts the buffer into several parts based on the numbers given as
arguments, and save them as separate
buffers. The intepretation of the numbers depends on the value of the
`/mode` option:

  * `deltax` (default): the numbers are the length (in terms of X) of
    the sub-buffers
  * `xvalues`: the numbers are the X values at which to split
  * `index` (or `indices`): the numbers are the indices of the points
    at which to split

If `/set-segments` is on, the X values not used to create independent
buffers but rather to set the position of the  [segments](#segments).

{::comment} description-end: chop {:/}

{::comment} synopsis-start: splita {:/}

### splita - Split first {#cmd-splita}

`splita` 


{::comment} synopsis-end: splita {:/}
{::comment} description-start: splita {:/}
Returns the first part of the buffer, until the first change of sign
of $$\Delta x$$. 

Useful to get the forward scan of a cyclic voltammogram.
{::comment} description-end: splita {:/}

{::comment} synopsis-start: splitb {:/}

### splitb - Split second {#cmd-splitb}

`splitb` 


{::comment} synopsis-end: splitb {:/}
{::comment} description-start: splitb {:/}
Returns the part of the buffer after the first change of sign
of $$\Delta x$$. 

Useful to get the backward scan of a cyclic voltammogram.
{::comment} description-end: splitb {:/}


{::comment} synopsis-start: split-monotonic {:/}

### split-monotonic - Split into monotonic parts {#cmd-split-monotonic}

`split-monotonic` 


{::comment} synopsis-end: split-monotonic {:/}
{::comment} description-start: split-monotonic {:/}
Splits the buffer into buffers where all parts have X values that
increase or decrease monotonically.
{::comment} description-end: split-monotonic {:/}
{::comment} synopsis-start: unwrap {:/}

### unwrap - Unwrap {#cmd-unwrap}

`unwrap` 


{::comment} synopsis-end: unwrap {:/}
{::comment} description-start: unwrap {:/}

This command makes the X values of the current buffer monotonic by
ensuring that the value of $$\Delta x$$ always have the same sign,
changing it if needs be.

This is useful for instance to convert a cyclic voltammogram from 
$$i = f(E)$$ to $$i = f(t)$$, after dividing by the scan rate.

{::comment} description-end: unwrap {:/}

{::comment} synopsis-start: cat {:/}

### cat - Concatenate {#cmd-cat}

`cat` _first_{:title="The number of a buffer in the stack"} _second..._{:title="Comma-separated lists of datasets in the stack"} `/add-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `i`

  * _first_{:title="The number of a buffer in the stack"}: First buffer
  * _second..._{:title="Comma-separated lists of datasets in the stack"}: Second buffer(s)
  * `/add-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on (default) segments are added between the old buffers

{::comment} synopsis-end: cat {:/}
{::comment} description-start: cat {:/}
Concatenates the buffers given as arguments, adding segment stops
inbetween (unless `/add-segments=false` is used). This can be used to
reverse the effect of the previous commands.

This does not change the number of columns. If you're trying to gather
several Y columns as a function of the same X, you should try
[`contract`](#cmd-contract) instead.
{::comment} description-end: cat {:/}



# Data filtering/processing

QSoas provides different ways to process data to remove unwanted
noise: 

 * Fourier transform filtering using [`filter-fft`](#cmd-filter-fft)
   or [`auto-filter-fft`](#cmd-auto-filter-fft).
 * Data approximation using basis splines via 
   [`filter-bsplines`](#cmd-filter-bsplines) or 
   [`auto-filter-bs`](#cmd-auto-filter-bs).
 * Splike removals using [`remove-spikes`](#cmd-remove-spikes).
 * You even may consider that manual point removal is filtering, in
   which case the [`deldp`](#cmd-deldp) command qualifies too.

In addition, QSoas provides ways to remove "baselines" (for a given
value of "base"):

 * splines-based baseline with [`baseline`](#cmd-baseline)
 * so-called catalytic baselines with 
   [`catalytic-baseline`](#cmd-catalytic-baseline)


{::comment} synopsis-start: filter-fft {:/}

### filter-fft - Filter {#cmd-filter-fft}

`filter-fft` `/derive=`_integer_{:title="An integer"} **(interactive)**

  * `/derive=`_integer_{:title="An integer"}: The starting order of derivation

{::comment} synopsis-end: filter-fft {:/}
{::comment} description-start: filter-fft {:/}
Filter data using FFT, ie the data is Fourier transformed, then a
filter function is applied to the frequency domain and the result is
backward transformed.

Cutoff can be changed using the mouse left/right buttons. Power
spectrum can be displayed using the `p` key, and the derivative can be
displayed with `d` (in which case you get the derivative of the signal
when accepting the data).

Behind the scenes, a cubic baseline is computed and subtracted from
the data to ensure that the data to which the FFT is applied has 0
value and 0 derivative on both sides. This greatly reduces artifacts
at the extremities of the dataset. This baseline is computed using a
small heuristic. You can display it using the `b` key.
{::comment} description-end: filter-fft {:/}

{::comment} synopsis-start: filter-bsplines {:/}

### filter-bsplines - Filter {#cmd-filter-bsplines}

`filter-bsplines` **(interactive)**


{::comment} synopsis-end: filter-bsplines {:/}
{::comment} description-start: filter-bsplines {:/}
Filters the data using B-splines takes the reverse approach of FFT
filtering. In FFT filtering, one takes the original data and *removes*
noise, with B-splines one constructs functions (linear combinations of
polynomes) and finds the one that is the closest to the original data.

This approach amounts to taking the projection of the original data
onto the subspace of the polynomial functions.

More information about the polynomial splines used can be found in
the [GSL documentation](http://www.gnu.org/software/gsl/manual/html_node/Overview-of-B_002dsplines.html).  

The result can be tuned by placing "nodes". Put more nodes in an area
where the data is not described properly by the smoothed
function. Increasing the order (using `+`) may help too.

Like for [`filter-fft`](#cmd-filter-fft), you can derive the data as
well pushing the `d` key.

Pushing the `o` keys optimizes the position of the segments in order
to minimize the difference between the data and the approximation.
{::comment} description-end: filter-bsplines {:/}

{::comment} synopsis-start: auto-filter-bs {:/}

### auto-filter-bs - Filter {#cmd-auto-filter-bs}

`auto-filter-bs` `/number=`_integer_{:title="An integer"} `/order=`_integer_{:title="An integer"} `/derivatives=`_integer_{:title="An integer"}

Alias: `afbs`

  * `/number=`_integer_{:title="An integer"}: Number of segments
  * `/order=`_integer_{:title="An integer"}: Order of the splines
  * `/derivatives=`_integer_{:title="An integer"}: Compute derivatives up to the given 

{::comment} synopsis-end: auto-filter-bs {:/}
{::comment} description-start: auto-filter-bs {:/}
Filters the data using B-splines in a non-interactive fashion.
Performs automatically an optimization step. 

This is mostly useful in scripts.
{::comment} description-end: auto-filter-bs {:/}


{::comment} synopsis-start: auto-filter-fft {:/}

### auto-filter-fft - Filter {#cmd-auto-filter-fft}

`auto-filter-fft` `/cutoff=`_integer_{:title="An integer"} `/derive=`_integer_{:title="An integer"}

Alias: `afft`

  * `/cutoff=`_integer_{:title="An integer"}: Number of segments
  * `/derive=`_integer_{:title="An integer"}: Differentiate to the given order

{::comment} synopsis-end: auto-filter-fft {:/}
{::comment} description-start: auto-filter-fft {:/}
Filters data using FFT in a non-interactive fashion.
Useful in scripts.
{::comment} description-end: auto-filter-fft {:/}

{::comment} synopsis-start: remove-spikes {:/}

### remove-spikes - Remove spikes {#cmd-remove-spikes}

`remove-spikes` `/number=`_integer_{:title="An integer"} `/factor=`_number_{:title="A floating-point number"} `/force-new=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `R`

  * `/number=`_integer_{:title="An integer"}: Number of points to look at
  * `/factor=`_number_{:title="A floating-point number"}: ...
  * `/force-new=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Adds a new buffer even if no spikes were removed

{::comment} synopsis-end: remove-spikes {:/}
{::comment} description-start: remove-spikes {:/}
Remove spikes using a simple heuristics
{::comment} description-end: remove-spikes {:/}

{::comment} synopsis-start: downsample {:/}

### downsample - Downsample {#cmd-downsample}

`downsample` `/factor=`_integer_{:title="An integer"}

  * `/factor=`_integer_{:title="An integer"}: Downsampling factor

{::comment} synopsis-end: downsample {:/}
{::comment} description-start: downsample {:/}
Creates a buffer with about _factor_ times less points than the
original buffer (default 10 times less) by averaging the original X
and Y values in groups of _factor_.
{::comment} description-end: downsample {:/}


{::comment} synopsis-start: baseline {:/}

### baseline - Baseline {#cmd-baseline}

`baseline` **(interactive)**

Alias: `b`


{::comment} synopsis-end: baseline {:/}
{::comment} description-start: baseline {:/}

Draw a baseline by placing points on the curve using the mouse (or off
the curve, after using key `o`). Baseline is computing using one of
several interpolation algorithms: C-splines, linear or polynomial
interpolation and Akima splines (the latter usually follows best the
accidents on the curve). Cycle between the various schemes using `c`.
{::comment} description-end: baseline {:/}

{::comment} synopsis-start: catalytic-baseline {:/}

### catalytic-baseline - Catalytic baseline {#cmd-catalytic-baseline}

`catalytic-baseline` **(interactive)**

Alias: `B`


{::comment} synopsis-end: catalytic-baseline {:/}
{::comment} description-start: catalytic-baseline {:/}
Draws a so-called "catalytic" baseline. There are several types of
baselines, but they all share the following features:

  * they are defined by 4 points
  * the first two points correspond to points where the baseline
    sticks to the data
  * the last two points give a "direction"

There are two baselines implemented for now:

  * a cubic baseline, that goes through the first two points and is
    parallel to the slope of the last two
  * an exponential baseline, that goes through the first two points
    and has the same ratio as the data for the last two points

{::comment} description-end: catalytic-baseline {:/}

{::comment} synopsis-start: auto-correlation {:/}

### auto-correlation - Auto-correlation {#cmd-auto-correlation}

`auto-correlation` 

Alias: `ac`


{::comment} synopsis-end: auto-correlation {:/}
{::comment} description-start: auto-correlation {:/}
Computes the auto-correlation function of the data, using FFT.
{::comment} description-end: auto-correlation {:/}
{::comment} synopsis-start: bin {:/}

### bin - Bin {#cmd-bin}

`bin` `/boxes=`_integer_{:title="An integer"} `/column=`_integer_{:title="An integer"} `/log=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/boxes=`_integer_{:title="An integer"}: 
  * `/column=`_integer_{:title="An integer"}: 
  * `/log=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 

{::comment} synopsis-end: bin {:/}
{::comment} description-start: bin {:/}
Bins the X values into various boxes (whose number can be controlled
using the `/boxes` option). The new buffer has for X values the center
of the boxes and as Y values the number of data points that were in
the boxes.
{::comment} description-end: bin {:/}


# Segments {#segments}

It if possible to split a buffer into logical segments. This does not
change the contents of the buffer, but the position of the segment
boundaries are marked by a vertical line. They can be used for
different purposes: for 
[segment-by-segment operations](#buffer-operations), 
step-by-step film loss correction
(using [`film-loss`](#cmd-film-loss)) or buffer splitting 
(using [`segments-chop`](#cmd-segments-chop)).

Segments can be detected using
[`find-steps`](#cmd-find-steps), set manually using
[`set-segments`](#cmd-set-segments) or [`chop`](#cmd-chop).

{::comment} synopsis-start: find-steps {:/}

### find-steps - Find steps {#cmd-find-steps}

`find-steps` `/average=`_integer_{:title="An integer"} `/threshold=`_number_{:title="A floating-point number"} `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/average=`_integer_{:title="An integer"}: Average over that many points
  * `/threshold=`_number_{:title="A floating-point number"}: Detection threshold
  * `/set-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to set the dataset segments

{::comment} synopsis-end: find-steps {:/}
{::comment} description-start: find-steps {:/}
This function detects ``jumps'' in the data (such as potential changes
in a chronoamperometry experiment, for instance), and display them
both to the terminal output and on the data display. 

If the option `/set-segments` is on, the segments of the dataset are
set to that found by `find-steps` (removing the ones previously
there).

{::comment} description-end: find-steps {:/}

{::comment} synopsis-start: set-segments {:/}

### set-segments - Set segments {#cmd-set-segments}

`set-segments` **(interactive)**


{::comment} synopsis-end: set-segments {:/}
{::comment} description-start: set-segments {:/}
Interactively prompts for the addition/removal of segments. A left
click adds a segment where the mouse is, while a right click removes
the closest segment.
{::comment} description-end: set-segments {:/}

{::comment} synopsis-start: segments-chop {:/}

### segments-chop - Chop into segments {#cmd-segments-chop}

`segments-chop` 


{::comment} synopsis-end: segments-chop {:/}
{::comment} description-start: segments-chop {:/}

Cuts the buffer into several ones based on the segments defined in the
current buffer. This way, the effect of a [`chop`](#cmd-chop)
`/set-segment=true` followed by `segments-chop` is the same as the
`chop` without `/set-segment=true`.

{::comment} description-end: segments-chop {:/}
{::comment} synopsis-start: film-loss {:/}

### film-loss - Film loss {#cmd-film-loss}

`film-loss` **(interactive)**


{::comment} synopsis-end: film-loss {:/}
{::comment} description-start: film-loss {:/}
Applies stepwise film loss correction (in the spirit of the $$K_m$$
experiments in [Fourmond _et al_, _Anal. Chem._,
*2009*](http://dx.doi.org/10.1021/ac8025702). For that, the current
buffer must be separated into segments, using
[`set-segments`](#cmd-set-segments), for instance. QSoas then zooms on
the first segment. Right and left clicking around the final linear
decay will set the value of the film loss rate constant for this
step. Push space to switch to the next step, and when you have done
everything, push `q` to obtain the corrected data.
{::comment} description-end: film-loss {:/}



# Operations involving several buffers {#buffer-operations}

It is possible to combine several buffers into one by applying
mathematical operations (subtraction, division and the like). Each of
these processes involve matching a point in a given buffer to a point
in another buffer. There are two ways to do that, chosen by the
`/mode` option:


 * with `/mode=xvalues`, the default, uses the values of X (ie the
   closest X value is picked). **Warning** this doesn't give the
   expected result for buffers with several times the same X values,
   such as full cyclic voltammograms.

 * with `/mode=indices`, points are matched on a one-to-one basis, ie
   point 1 of dataset 1 to point 2 of dataset 2, irrespective of the X
   values.

In addition to that, the operations can make use of the segments
defined on each buffer (see [`find-steps`](#cmd-find-steps) and
[`set-segments`](#cmd-set-segments)). If segments are defined and
`/use-segments=true`, then the operations are applied
segment-by-segment, with the first point of each segment matching the
corresponding point in the other buffer. This mode is particularly
useful to manipulate series of potential steps when some series are
using shorter times than others.

{::comment} synopsis-start: div {:/}

### div - Divide {#cmd-div}

`div` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: div {:/}
{::comment} description-start: div {:/}
Divides all buffers by the last one. This is useful to get rid of film
loss when one have an independent measure of film loss, see
[Fourmond _et al_, Anal. Chem. 2009](http://dx.doi.org/10.1021/ac8025702)
for more information on that way to use divisions.
{::comment} description-end: div {:/}

{::comment} synopsis-start: subtract {:/}

### subtract - Subtract {#cmd-subtract}

`subtract` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `S`

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: subtract {:/}
{::comment} description-start: subtract {:/}
Subtracts the last buffer from all the other ones. Useful for standard
baseline removal.
{::comment} description-end: subtract {:/}

{::comment} synopsis-start: average {:/}

### average - Average {#cmd-average}

`average` _buffers..._{:title="Comma-separated lists of datasets in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _buffers..._{:title="Comma-separated lists of datasets in the stack"}: Buffers
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment
  * `/split=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, buffers are automatically split into monotonic parts before averaging.

{::comment} synopsis-end: average {:/}
{::comment} description-start: average {:/}
In a manner similar to [`subtract`](#cmd-subtract) and
[`divide`](#cmd-divide), the `average` command averages all the
buffers given into one, with the same segment-by-segment capacities.

An additional feature of `average`, though is its ability to first
split the buffers into monotonic parts before averaging (when `/split`
is on). That is even the default in the case when only one buffer is
provided. This proves useful for averaging the forward and return scan
in a cyclic voltammogram.
{::comment} description-end: average {:/}

{::comment} synopsis-start: merge {:/}

### merge - Merge buffers on X values {#cmd-merge}

`merge` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: merge {:/}
{::comment} description-start: merge {:/}
Merge the second buffer with the first one, and keep Y of the second
as a function of Y of the first. The algorithm for finding which point
in the second corresponds to a given one in the first is the same as
that of the other buffers. 

If more than two buffers are specified, the last one gets merged to
all the ones before.
{::comment} description-end: merge {:/}

{::comment} synopsis-start: contract {:/}

### contract - Group buffers on X values {#cmd-contract}

`contract` _first..._{:title="Comma-separated lists of datasets in the stack"} _second_{:title="The number of a buffer in the stack"} `/mode=`_choice_{:title="One of: indices, xvalues"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _first..._{:title="Comma-separated lists of datasets in the stack"}: First buffer(s)
  * _second_{:title="The number of a buffer in the stack"}: Second buffer
  * `/mode=`_choice_{:title="One of: indices, xvalues"}: Whether operations try to match x values or indices
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, operations are performed segment-by-segment

{::comment} synopsis-end: contract {:/}
{::comment} description-start: contract {:/}
As may be anticipated from the name, `contract` does the reverse of 
[`expand`](#cmd-expand), ie it regroups in one buffer several values
of Y that run against the same values of X. The result is a buffer
that contains as many Y columns as the total of Y columns of all the
arguments. X matching between the buffers is done as for the other
operations such as [`div`](#cmd-div) or  [`subtract`](#cmd-subtract).
{::comment} description-end: contract {:/}

# Data inspection facilities

{::comment} synopsis-start: find-peaks {:/}

### find-peaks - Find peaks {#cmd-find-peaks}

`find-peaks` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/peaks=`_integer_{:title="An integer"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default
  * `/peaks=`_integer_{:title="An integer"}: Display only that many peaks (by order of intensity)

{::comment} synopsis-end: find-peaks {:/}
{::comment} description-start: find-peaks {:/}
Find all the peaks of the current dataset. If `/output` is on, then
the peak data is written to the output file. This function will find
many peaks on noisy data, you can limit to the first _n_ ones by using 
`/peaks=`_n_.

Peaks are indicated on the buffer using lines, and their position is
written to the terminal.
{::comment} description-end: find-peaks {:/}

{::comment} synopsis-start: echem-peaks {:/}

### echem-peaks - Find peaks pairs {#cmd-echem-peaks}

`echem-peaks` 


{::comment} synopsis-end: echem-peaks {:/}
{::comment} description-start: echem-peaks {:/}
This function tries to find "pairs" of peaks that may be the anodic
and cathodic peaks of a redox couple, and outputs useful information
about those.
{::comment} description-end: echem-peaks {:/}

{::comment} synopsis-start: 1 {:/}

### 1 - Find peak {#cmd-1}

`1` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default

{::comment} synopsis-end: 1 {:/}
{::comment} description-start: 1 {:/}
Essentially equivalent to 

~~~~
QSoas> find-peaks /peaks=1 /output=true
~~~~
{::comment} description-end: 1 {:/}

{::comment} synopsis-start: 2 {:/}

### 2 - Find two peak {#cmd-2}

`2` `/window=`_integer_{:title="An integer"} `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/window=`_integer_{:title="An integer"}: ...
  * `/include-borders=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ...
  * `/output=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether peak information should be written to output file by default

{::comment} synopsis-end: 2 {:/}
{::comment} description-start: 2 {:/}
Essentially equivalent to 

~~~~
QSoas> find-peaks /peaks=2 /output=true
~~~~
{::comment} description-end: 2 {:/}


{::comment} synopsis-start: stats {:/}

### stats - Statistics {#cmd-stats}

`stats` `/buffer=`_buffer_{:title="The number of a buffer in the stack"} `/to-file=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/buffer=`_buffer_{:title="The number of a buffer in the stack"} (default): An alternative buffer to get information on
  * `/to-file=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Also write stats to output file
  * `/use-segments=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Make statistics segments by segment

{::comment} synopsis-end: stats {:/}
{::comment} description-start: stats {:/}
Stats display various statistics about the current buffer (or the one
specified as the `/buffer` option). The exact list of statistics
displayed grows slowly with time and needs. It is currently, for each
column:

 * the first and last values (displayed with the index)
 * the `_min` and `_max` values
 * the average
 * `_var`, the variance
 * the `_norm`, ie the square root of the sum of the squares
 * for Y columns, the integral is also displayed, indexed by `_int`.

Statistics can be written to the output file with `/to-file=true`. If
you specify `/use-segments=true`, the statistics are also displayed
segment-by-segment (and written out to the output file if asked for).

{::comment} description-end: stats {:/}

{::comment} synopsis-start: cursor {:/}

### cursor - Cursor {#cmd-cursor}

`cursor` **(interactive)**

Alias: `cu`


{::comment} synopsis-end: cursor {:/}
{::comment} description-start: cursor {:/}
Position a cursor on the curve to know its exact X and Y positions. 

Using the right mouse button, it is also possible to position a
reference point. After that the difference in X,Y coordinates between
the cursor and the reference point is also displayed.

Cursor positions can be saved to the output file by pressing the space
bar.

{::comment} description-end: cursor {:/}

{::comment} synopsis-start: reglin {:/}

### reglin - Linear regression {#cmd-reglin}

`reglin` **(interactive)**

Alias: `reg`


{::comment} synopsis-end: reglin {:/}
{::comment} description-start: reglin {:/}
Linear regression. Using the left and right mouse buttons, select a
region whose slope is of interest. The terminal shows the $$a$$ and $$b$$
parameters, and also the effective first order rate constant, ie the
$$k$$ parameter of the equation

$$ f_0 \exp \left[-k \, (x - x_0) \right] $$

with values that match the same initial slope.

Using the space bar it is possible to save the values displayed in the
terminal to the output file.
{::comment} description-end: reglin {:/}




# Fits 

QSoas is particularly good when it comes to fitting data, and allows
for complex fits, and in particular multi-buffer fits, when functions
with shared parameters are fit to different buffers. Fits fall into
two different categories:

 * mono-buffer fits, ie fits that apply to one buffer, but that can be
   applied to several buffers at the same time with shared parameters
 * multi-buffer fits, ie fits that need at least two buffers to work

Fits provide several commands: all provide a `mfit-`_fit_ and a
`sim-`_fit_ command, and mono-buffer fits provide a `fit-`_fit_ in
addition.

 * The `fit` command fits a single buffer, when the fits allows
   that. It takes no argument
 * The `mfit` command fits several buffers at the same time. It takes
   the numbers of the buffers it will work on.
 * The `sim` command takes a saved parameters file and a series of
   buffers, and pushes the data computed from the parameters on the
   stack.

In addition to these commands, QSoas provides commands to combine fits
together and to create fit to fit derivatives of the signals.


{::comment} synopsis-start: combine-fits {:/}

### combine-fits - Combine fits {#cmd-combine-fits}

`combine-fits` _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _fits..._

  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: The name of the new fit
  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: How to combine the various fits
  * _fits..._: The fit to combine together

{::comment} synopsis-end: combine-fits {:/}
{::comment} description-start: combine-fits {:/}
Creates a new fit named _name_ based on other fits, combined through a
formula.
{::comment} description-end: combine-fits {:/}

{::comment} synopsis-start: define-derived-fit {:/}

### define-derived-fit - Create a derived fit {#cmd-define-derived-fit}

`define-derived-fit` _fit_ `/mode=`_choice_{:title="One of: combined, deriv-only, separated"}

  * _fit_: The fit to make a derived fit of
  * `/mode=`_choice_{:title="One of: combined, deriv-only, separated"}: Whether one fits only the derivative, both the derivative and the original data together or separated

{::comment} synopsis-end: define-derived-fit {:/}
{::comment} description-start: define-derived-fit {:/}
Defines a new fit based on the already defined _fit_ that will fit:

  * only the derivative if `/mode=deriv-only`
  * the original function in one buffer and the derivative in the
    second if `/mode=separated`
  * both the original function and the derivative in a single buffer
    (the derivative is assumed to be the data after the first
    discontinuity in the X values) if `/mode=combined`

This function is explained in more details in the [tutorial](tutorial.html).  
{::comment} description-end: define-derived-fit {:/}


## Exponential fits

There are several ways to fit exponentials to data. The simplest is by
far the [`fit-exponential-decay`](#cmd-fit-exponential-decay) that
fits a decay with an arbitrary number of exponentials to the data.

{::comment} synopsis-start: fit-exponential-decay {:/}

### fit-exponential-decay - Fit: Multi-exponential fits {#cmd-fit-exponential-decay}

`fit-exponential-decay` `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there an overall fully exponential loss ?
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase ?
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-exponential-decay {:/}
{::comment} description-start: fit-exponential-decay {:/}
Fits to the formula:

$$ \left(A_\infty + \sum_{i=1}^n A_i \exp(-(x - x_0)/\tau_i) + b\,
x\right) \exp (- k_{loss}(x - x_0))$$

$$b\,x$$ is only present if the `/slow` option is on, and $$k_{loss}$$
is not 0 only if `/loss` is on. If `/relative` is on, $$A_i$$ is not
a parameter of the fit, but $$\alpha_i$$ defined by 
$$A_i = \alpha_i A_\infty$$.  
This should not be used to fit data that tend to 0.

{::comment} description-end: fit-exponential-decay {:/}

{::comment} synopsis-start: mfit-exponential-decay {:/}

### mfit-exponential-decay - Multi fit: Multi-exponential fits {#cmd-mfit-exponential-decay}

`mfit-exponential-decay` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there an overall fully exponential loss ?
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase ?
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-exponential-decay {:/}
{::comment} description-start: mfit-exponential-decay {:/}
Multi-buffer version of the
[`fit-exponential-decay`](#cmd-fit-exponential-decay) fit.
{::comment} description-end: mfit-exponential-decay {:/}


{::comment} synopsis-start: sim-exponential-decay {:/}

### sim-exponential-decay - Fit: Multi-exponential fits {#cmd-sim-exponential-decay}

`sim-exponential-decay` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/absolute=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Amplitude is absolute or relative to the asymptote ?
  * `/loss=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there an overall fully exponential loss ?
  * `/slow=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Is there a very slow phase ?
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-exponential-decay {:/}
{::comment} description-start: sim-exponential-decay {:/}
Simulation command for the
[`fit-exponential-decay`](#cmd-fit-exponential-decay) fit.
{::comment} description-end: sim-exponential-decay {:/}


{::comment} synopsis-start: fit-multiexp-multistep {:/}

### fit-multiexp-multistep - Fit: Multi-step and multi-exponential {#cmd-fit-multiexp-multistep}

`fit-multiexp-multistep` `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-multiexp-multistep {:/}
{::comment} description-start: fit-multiexp-multistep {:/}
Single buffer fit:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: fit-multiexp-multistep {:/}


{::comment} synopsis-start: mfit-multiexp-multistep {:/}

### mfit-multiexp-multistep - Multi fit: Multi-step and multi-exponential {#cmd-mfit-multiexp-multistep}

`mfit-multiexp-multistep` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-multiexp-multistep {:/}
{::comment} description-start: mfit-multiexp-multistep {:/}
multi buffer fit:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: mfit-multiexp-multistep {:/}

{::comment} synopsis-start: sim-multiexp-multistep {:/}

### sim-multiexp-multistep - Fit: Multi-step and multi-exponential {#cmd-sim-multiexp-multistep}

`sim-multiexp-multistep` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/exponentials=`_integer_{:title="An integer"} `/steps=`_integers_{:title="A comma-separated list of integers"} `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/exponentials=`_integer_{:title="An integer"}: Number of exponentials
  * `/steps=`_integers_{:title="A comma-separated list of integers"}: Step list with numbered conditions
  * `/independent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether irreversible loss is independent on each step
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-multiexp-multistep {:/}
{::comment} description-start: sim-multiexp-multistep {:/}
fit simulation:
Fits of exponentials on several steps with film loss bookkeeping
{::comment} description-end: sim-multiexp-multistep {:/}

## Arbitrary fits

QSoas provides ways to fit arbitrary formulas (written in
[Ruby](#ruby)) to data. While it is possible to do that on a
case-by-case basis using [`fit-arb`](#cmd-fit-arb), it is also
possible to store formulas in a plain text file and load them using 
[`load-fits`](#cmd-load-fits). 

For the time being, arbitrary fits don't have a `sim-` command (but to
get roughly the same effect, you can use
[`apply-formyla`](#cmd-apply-formula).

{::comment} synopsis-start: fit-arb {:/}

### fit-arb - Fit: Arbitrary fit {#cmd-fit-arb}

`fit-arb` _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: \|-separated formulas for the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-arb {:/}
{::comment} description-start: fit-arb {:/}
Fits _formula_ to the current buffer. _formula_ is a \|-separated list
of [Ruby](#ruby) formulas that apply to different buffers (of course,
if you specify more than one formula that way, you must use the
[`mfit-arb`](#cmd-mfit-arb) command, see its documentation for more
information). 

Parameters are auto-detected. Some parameters are treated
specifically:
 * `x_0` and `y_0` are fixed by default and initialized to the first
   X or Y value of the buffer the fit applies to;
 * `temperature` is also fixed and set to the current
   [temperature](#cmd-temperature)
 * Using `fara` counts as using `temperature` excepted that its value is
   $$f = F/RT$$. You never get `fara` as a fit parameter.
{::comment} description-end: fit-arb {:/}

{::comment} synopsis-start: mfit-arb {:/}

### mfit-arb - Multi fit: Arbitrary fit {#cmd-mfit-arb}

`mfit-arb` _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _formulas_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: \|-separated formulas for the fit
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-arb {:/}
{::comment} description-start: mfit-arb {:/}
Same as [`fit-arb`](#cmd-fit-arb), but for multiple buffers.

If only one formula is specified, the same formula is applied to all
buffers (with, as usual, the possibility to select which parameters
are global or buffer-local).

If more than one formula is specified, the exact same number of
buffers should be supplied; the first formula applies to the first
buffer, the second formula to the second buffer, and so on... For
instance, if you run:

~~~~
QSoas> mfit-arb a*x+b|a*x+c|a*x+d 0 1 2
~~~~

Buffer 0 get fits with `a*x+b`, 1 with `a*x+c` and 2 with `a*x+d`.

{::comment} description-end: mfit-arb {:/}

{::comment} synopsis-start: load-fits {:/}

### load-fits - Load fits {#cmd-load-fits}

`load-fits` _file_{:title="Path of a file (or a directory)"}

  * _file_{:title="Path of a file (or a directory)"}: File containing the fits to load

{::comment} synopsis-end: load-fits {:/}
{::comment} description-start: load-fits {:/}
Load arbitrary fits from a plain text file. The fits are turned into
normal QSoas fits (which means they can be used with
[`define-derived-fit`](#cmd-define-derived-fit) or
[`combine-fits`](#cmd-combine-fits) for instance). Files should look
like this:

~~~~
# Comments are allowed
michaelis: vmax/(1 + km/x)
sigm-log: log((exp(a_red*log(10.0)) +exp(a_ox*log(10.0)) * \
          exp(-fara*(x-e0)))/ \
          (1 + exp(-fara*(x-e0))))
~~~~

Comments are allowed, as are line continuations with `\`.


{::comment} description-end: load-fits {:/}

{::comment} synopsis-start: custom-fit {:/}

### custom-fit - Define fit {#cmd-custom-fit}

`custom-fit` _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _name_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Name for the new fit
  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Mathematical expression for the fit

{::comment} synopsis-end: custom-fit {:/}
{::comment} description-start: custom-fit {:/}
Directly defines a custom fit with the given _name_ and
_formula_. Equivalent to having a line

<pre>
<i>name</i>: <i>formula</i>
</pre>

in a file loaded by [`load-fits`](#cmd-load-fits).
{::comment} description-end: custom-fit {:/}


## Redox titration fits

{::comment} synopsis-start: fit-nernst {:/}

### fit-nernst - Fit: Nerstian behaviour {#cmd-fit-nernst}

`fit-nernst` `/states=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-nernst {:/}
{::comment} description-start: fit-nernst {:/}
Fits the absorbance (or anything else) of a single chemical species
present under several redox states as a function of the potential,
using the Nernst equation.

The number of redox states is given to the option `/states` (defaults
to 2). The states are numbered from 0, which is the most reduced
state. $$A_i$$ is the absorbance (or whatever else) of the state
numbered $$i$$.

This fit is useful to fit the results of a the redox titration at a
single wavelength. If several wavelength are available, separate them
into several buffers as a function of the potential and fit them using
[`mfit-nernst`](#cmd-mfit-nernst), while keeping the redox potentials
(and electron numbers) global and only the absorbances as
buffer-local.
{::comment} description-end: fit-nernst {:/}

{::comment} synopsis-start: mfit-nernst {:/}

### mfit-nernst - Multi fit: Nerstian behaviour {#cmd-mfit-nernst}

`mfit-nernst` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/states=`_integer_{:title="An integer"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-nernst {:/}
{::comment} description-start: mfit-nernst {:/}
Multi-buffer version of [`fit-nernst`](#cmd-fit-nernst). To be used
for fitting multi-wavelength redox titrations.
{::comment} description-end: mfit-nernst {:/}

{::comment} synopsis-start: sim-nernst {:/}

### sim-nernst - Fit: Nerstian behaviour {#cmd-sim-nernst}

`sim-nernst` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/states=`_integer_{:title="An integer"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/states=`_integer_{:title="An integer"}: Number of redox states
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-nernst {:/}
{::comment} description-start: sim-nernst {:/}
Simulation command for [`fit-nernst`](#cmd-fit-nernst)
{::comment} description-end: sim-nernst {:/}


## Kinetic systems

It is possible with QSoas to fit kinetic traces that follow the
concentration of one or more species that are part of a full kinetic
system. For that, you need to write a simple text file of the
following form:

~~~~
A <=>[k_i][k_a] I1
I1 ->[k_i2 * o2] I2
~~~~

This describes a kinetic system with three species, `A`, `I1` and
`I2`, with a reversible reaction from `A` to `I1` with a forward
rate of `k_i` and a backward rate of `k_a`, and an irreversible
reaction from `I1` to `I2` with a rate of `k_i2 * o2`. 

The files can contain comment lines starting with a `#`, and can
contain an arbitrary large number of reactions.

QSoas automatically detects the parameters from the fit, here `k_i`,
`k_a`, `k_i2` and `o2`.

It is possible to assign special time dependence to any of the
parameters by using the `/with` option: 

~~~~
QSoas> fit-kinetic-system /with=o2:3,exp kinetic-file.txt
~~~~

This gives to `o2` the value of the sum of three exponential decays
shifted in time (see formula below).

There is for now only one type of time-dependence:

  * `exp`, where the given parameter, `p` is given by:

  $$ p = \sum_{i=1}^n p_i \exp \left( - \frac{t -
  t^p_i}{\tau^p_i}\right) \times H(t - t^p_i)$$

  where $$H$$ is the heavyside step function (1 for positive argument,
  0 else) and $$n$$ is the number given just after `:` (in the above
  command-line, that means you will have three different steps). You
  may wish to have all $$\tau$$ values common, which you do by adding
  `,common` in the spec:

~~~~
QSoas> fit-kinetic-system /with=o2:3,exp,common kinetic-file.txt
~~~~


{::comment} synopsis-start: fit-kinetic-system {:/}

### fit-kinetic-system - Fit: Full kinetic system {#cmd-fit-kinetic-system}

`fit-kinetic-system` _system_{:title="Path of a file (or a directory)"} `/with=`_texts_ `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-kinetic-system {:/}
{::comment} description-start: fit-kinetic-system {:/}
Fits a full kinetic system. The fitted value is a linear combination
of all the concentrations, with the coefficients given by parameters
of name `y_A` (for the coefficient for the concentration of species
`A`, for instance).
{::comment} description-end: fit-kinetic-system {:/}

{::comment} synopsis-start: mfit-kinetic-system {:/}

### mfit-kinetic-system - Multi fit: Full kinetic system {#cmd-mfit-kinetic-system}

`mfit-kinetic-system` _system_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/with=`_texts_ `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-kinetic-system {:/}
{::comment} description-start: mfit-kinetic-system {:/}
Multi-buffer variant of the
[`kinetic-system`](#cmd-fit-kinetic-system) fit.
{::comment} description-end: mfit-kinetic-system {:/}

{::comment} synopsis-start: sim-kinetic-system {:/}

### sim-kinetic-system - Fit: Full kinetic system {#cmd-sim-kinetic-system}

`sim-kinetic-system` _system_{:title="Path of a file (or a directory)"} _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/with=`_texts_ `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _system_{:title="Path of a file (or a directory)"}: Path to the file describing the system
  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/with=`_texts_: Dependency upon time of various parameters
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-kinetic-system {:/}
{::comment} description-start: sim-kinetic-system {:/}
Computation for the 
[`kinetic-system`](#cmd-fit-kinetic-system) fit.
{::comment} description-end: sim-kinetic-system {:/}




## Slow scans fits

These specific fits were used in the context of the interpretation of
cyclic voltammograms of adorbed nickel-iron hydrogenase that undergo
inactivations under oxidizing conditions. For more information, refer
to [Abou-Hamdam _et al_, __PNAS__ 2012](http://dx.doi.org/10.1073/pnas.1212258109)
(which you probably should cite anyway if you use them).

{::comment} synopsis-start: fit-slow-scan-hp {:/}

### fit-slow-scan-hp - Fit: Slow scan test {#cmd-fit-slow-scan-hp}

`fit-slow-scan-hp` `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-slow-scan-hp {:/}
{::comment} description-start: fit-slow-scan-hp {:/}
Fit for the "high-potential" part of a slow voltammetric scan where
inactivation occurs with rate constants that do not depend on
time. The current for the active form is assumed to depend linearly on
the potential.

Formula:

$$ i_{forward} = (a + b \times E) \left[\left(A_1  A_e\right) \times \exp\left\{(EE_1)/(\nu \tau)\right\} + A_e\right]  $$

$$ i_{backward} = (a + b \times E) \left[\left(A_1  A_e\right) \times \exp\left\{(2E_vE_1-E)/(\nu \tau)\right\} + A_e\right]  $$

where $$E_v$$ is the vertex potential, $$E_1$$ is the initial potential,
$$\tau$$ the rate constant of decrease, $$A_1$$ the amount of initially
active enzyme, $$A_e$$ the equilibrium concentration of active species
and $\nu$ the scan rate.

{::comment} description-end: fit-slow-scan-hp {:/}

{::comment} synopsis-start: fit-slow-scan-lp {:/}

### fit-slow-scan-lp - Fit: Slow scan test {#cmd-fit-slow-scan-lp}

`fit-slow-scan-lp` `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-slow-scan-lp {:/}
{::comment} description-start: fit-slow-scan-lp {:/}
Fit for the "low-potential" part of a slow voltammetric scan where the
enzyme reactivates with a rate constant that depends exponentially on
the potential: 

$$ k_a = k \exp(- \alpha f E)$$

The overall formula is:

$$ i(E) = \underbrace{(A\times E+B)}_{\text{stationnary current}}
   \underbrace{\left(  1 - (1-y_1) \exp^{-\frac{k}{\alpha f \nu}
   (\exp^{\alpha f E}-\exp^{\alpha f E_1})}\right)}_
   {\text{active fraction}} $$

$$E_1$$ is the initial potential, $$\nu$$ the scan rate

{::comment} description-end: fit-slow-scan-lp {:/}

{::comment} synopsis-start: mfit-slow-scan-hp {:/}

### mfit-slow-scan-hp - Multi fit: Slow scan test {#cmd-mfit-slow-scan-hp}

`mfit-slow-scan-hp` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-slow-scan-hp {:/}
{::comment} description-start: mfit-slow-scan-hp {:/}
Multi-buffer variant of the
[`fit-slow-scan-hp`](#cmd-fit-slow-scan-hp) fit.
{::comment} description-end: mfit-slow-scan-hp {:/}

{::comment} synopsis-start: mfit-slow-scan-lp {:/}

### mfit-slow-scan-lp - Multi fit: Slow scan test {#cmd-mfit-slow-scan-lp}

`mfit-slow-scan-lp` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-slow-scan-lp {:/}
{::comment} description-start: mfit-slow-scan-lp {:/}
Multi-buffer variant of the
[`fit-slow-scan-lp`](#cmd-fit-slow-scan-lp) fit.
{::comment} description-end: mfit-slow-scan-lp {:/}

{::comment} synopsis-start: sim-slow-scan-lp {:/}

### sim-slow-scan-lp - Fit: Slow scan test {#cmd-sim-slow-scan-lp}

`sim-slow-scan-lp` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/explicit-rate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the scan rate is an explicit parameter of the fit
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-slow-scan-lp {:/}
{::comment} description-start: sim-slow-scan-lp {:/}
Computation for the 
[`slow-scan-lp`](#cmd-fit-slow-scan-lp) fit.
{::comment} description-end: sim-slow-scan-lp {:/}

{::comment} synopsis-start: sim-slow-scan-hp {:/}

### sim-slow-scan-hp - Fit: Slow scan test {#cmd-sim-slow-scan-hp}

`sim-slow-scan-hp` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/bi-exp=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether we have a bi-exponential or a mono-exponential
  * `/scaling=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Use an additional scaling factor
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-slow-scan-hp {:/}
{::comment} description-start: sim-slow-scan-hp {:/}
Computation for the 
[`slow-scan-hp`](#cmd-fit-slow-scan-hp) fit.
{::comment} description-end: sim-slow-scan-hp {:/}



## Wave shape fits

These fits correspond to the various models described in 
[Fourmond _et al_, *JACS*2013](http://dx.doi.org/10.1021/ja311607s):

 * [`fit-eecr-wave`](#cmd-fit-eecr-wave) is the *EEC* model
 * [`fit-ecr-wave`](#cmd-fit-ecr-wave) is the *EC* model
 * [`fit-eecr-relay-wave`](#cmd-fit-eecr-relay-wave) is the *EECR*
   model

Please refer to that paper for more information.


{::comment} synopsis-start: fit-eecr-wave {:/}

### fit-eecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-fit-eecr-wave}

`fit-eecr-wave` `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-eecr-wave {:/}
{::comment} description-start: fit-eecr-wave {:/}
Fits the so-called EEC model in [Fourmond _et al_, *JACS*2013](http://dx.doi.org/10.1021/ja311607s) 
to the data.

If `/plateau` is off (default), then the equation used is that for the
limit where the dispersion of values of $$k_0$$ 
large $$\beta d_0 \to \infty$$, while the full expression is used in
the other case.

If `/oxidation` is true, the reference current is the oxidation current
(and not the reduction current as is the default).

If `/use-eoc` is true, then the open circuit potential is used as a
parameter rather than the ratio $$k_2/k_{-2}$$.
{::comment} description-end: fit-eecr-wave {:/}


{::comment} synopsis-start: mfit-eecr-wave {:/}

### mfit-eecr-wave - Multi fit: Fit of an EECR catalytic wave {#cmd-mfit-eecr-wave}

`mfit-eecr-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-eecr-wave {:/}
{::comment} description-start: mfit-eecr-wave {:/}
Multi-buffer variant of [`fit-eecr-wave`](#cmd-fit-eecr-wave).
{::comment} description-end: mfit-eecr-wave {:/}

{::comment} synopsis-start: sim-eecr-wave {:/}

### sim-eecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-sim-eecr-wave}

`sim-eecr-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-eecr-wave {:/}
{::comment} description-start: sim-eecr-wave {:/}
Simulation for the [`eecr-wave`](#cmd-fit-eecr-wave) fit.
{::comment} description-end: sim-eecr-wave {:/}


{::comment} synopsis-start: fit-eecr-relay-wave {:/}

### fit-eecr-relay-wave - Fit: Fit of an EECR+relay catalytic wave {#cmd-fit-eecr-relay-wave}

`fit-eecr-relay-wave` `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-eecr-relay-wave {:/}
{::comment} synopsis-start: mfit-eecr-relay-wave {:/}

### mfit-eecr-relay-wave - Multi fit: Fit of an EECR+relay catalytic wave {#cmd-mfit-eecr-relay-wave}

`mfit-eecr-relay-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-eecr-relay-wave {:/}
{::comment} synopsis-start: sim-eecr-relay-wave {:/}

### sim-eecr-relay-wave - Fit: Fit of an EECR+relay catalytic wave {#cmd-sim-eecr-relay-wave}

`sim-eecr-relay-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-eecr-relay-wave {:/}

{::comment} synopsis-start: fit-ecr-wave {:/}

### fit-ecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-fit-ecr-wave}

`fit-ecr-wave` `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)

{::comment} synopsis-end: fit-ecr-wave {:/}
{::comment} synopsis-start: mfit-ecr-wave {:/}

### mfit-ecr-wave - Multi fit: Fit of an EECR catalytic wave {#cmd-mfit-ecr-wave}

`mfit-ecr-wave` _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/parameters=`_file_{:title="Path of a file (or a directory)"} `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} **(interactive)**

  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/parameters=`_file_{:title="Path of a file (or a directory)"}: Pre-loads parameters
  * `/debug=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Turn on debugging (for QSoas developers only)
  * `/weight-buffers=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to weight buffers (off by default)

{::comment} synopsis-end: mfit-ecr-wave {:/}
{::comment} synopsis-start: sim-ecr-wave {:/}

### sim-ecr-wave - Fit: Fit of an EECR catalytic wave {#cmd-sim-ecr-wave}

`sim-ecr-wave` _parameters_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"} `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _parameters_{:title="Path of a file (or a directory)"}: File to load parameters from
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: Datasets to fit
  * `/plateau=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use the general expression or only that valid when plateaus are not reached
  * `/oxidation=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: ???
  * `/use-eoc=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether to use explicitly the bias or compute it using the open circuit potential
  * `/override=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: A comma-separated list of parameters to override
  * `/extra-parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Define supplementary parameters
  * `/reexport=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Do not compute data, just re-export fit parameters and errors

{::comment} synopsis-end: sim-ecr-wave {:/}

# Computation/simulations functions

The commands in this section in general don't deal with experimental
data, though most require a buffer to work on, to act as a model for
the X values. If you're not trying to reproduce experimental data,
generate the buffers using [`generate-buffer`](#cmd-generate-buffer).

## Evaluation functions

While it is not its primary purpose, QSoas provides various functions
to evaluate the result of mathematical operations.

{::comment} synopsis-start: eval {:/}

### eval - Ruby eval {#cmd-eval}

`eval` _code_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _code_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: Any ruby code

{::comment} synopsis-end: eval {:/}
{::comment} description-start: eval {:/}
Evaluates the given code as a Ruby expression:

~~~~
QSoas> eval 2*3
 => 6
~~~~

It runs in the same environment as the
[`apply-formula`](#cmd-apply-formula) and the custom fits (excepted,
of course, that there are no `x` and `y` variables). It can be useful
to check that a function has been correctly defined in a file loaded
by [`ruby-run`](#cmd-ruby-run).
{::comment} description-end: eval {:/}

{::comment} synopsis-start: find-root {:/}

### find-root - Finds a root {#cmd-find-root}

`find-root` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _seed_{:title="A floating-point number"} `/max=`_number_{:title="A floating-point number"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: An expression of 1 variable (not an equation !)
  * _seed_{:title="A floating-point number"}: Initial X value from which to search
  * `/max=`_number_{:title="A floating-point number"} (default): If present, uses dichotomy between seed and max

{::comment} synopsis-end: find-root {:/}
{::comment} description-start: find-root {:/}

Find the root of the given `x`-dependent expression using an iterative
algorithm, using _seed_ as the initial value. If the `/max` option is
specified, then the search proceeds using dichotomy between the two
values.

~~~~
QSoas> find-root 'x**2 - 3' 1
Found root at: 1.73205
~~~~

Do not use a equal sign. The returned value is that for which the
expression is 0.
{::comment} description-end: find-root {:/}
{::comment} synopsis-start: integrate {:/}

### integrate - Integrate expression {#cmd-integrate}

`integrate` _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} _a_{:title="A floating-point number"} _b_{:title="A floating-point number"} `/integrator=`_choice_{:title="One of: gauss15, gauss21, gauss31, gauss41, gauss51, gauss61, qng"} `/relative-int=`_number_{:title="A floating-point number"} `/absolute-int=`_number_{:title="A floating-point number"}

  * _formula_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: An expression of 1 variable (not an equation !)
  * _a_{:title="A floating-point number"}: Left bound of the segment
  * _b_{:title="A floating-point number"}: Right bound of the segment
  * `/integrator=`_choice_{:title="One of: gauss15, gauss21, gauss31, gauss41, gauss51, gauss61, qng"}: The algorithm used for integration
  * `/relative-int=`_number_{:title="A floating-point number"}: Relative precision required for integration
  * `/absolute-int=`_number_{:title="A floating-point number"}: Absolute precision required for integration

{::comment} synopsis-end: integrate {:/}
{::comment} description-start: integrate {:/}
Computes the integral of the given expression of `x` between bounds
_a_ and _b_:

~~~~
QSoas> integrate x**2 10 22
Integral value: 3216	estimated error: 3.57048e-11	 in 31 evaluations over 1 intervals 
~~~~

{::comment} description-end: integrate {:/}

{::comment} synopsis-start: generate-buffer {:/}

### generate-buffer - Generate buffer {#cmd-generate-buffer}

`generate-buffer` _start_{:title="A floating-point number"} _end_{:title="A floating-point number"} `/samples=`_integer_{:title="An integer"} `/formula=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _start_{:title="A floating-point number"}: The first X value
  * _end_{:title="A floating-point number"}: The last X value
  * `/samples=`_integer_{:title="An integer"}: The number of samples
  * `/formula=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Formula to generate the Y values

{::comment} synopsis-end: generate-buffer {:/}
{::comment} description-start: generate-buffer {:/}
Generates a buffer with _samples_ samples (by default 1000) uniformly
spaced between _start_ and _end_.

If formula is provided, it sets Y values according to this formula
(else Y is take equal to X).


~~~~
QSoas> generate-buffer -10 10 sin(x)
~~~~
{::comment} description-end: generate-buffer {:/}

## Simulation functions



{::comment} synopsis-start: kinetic-system {:/}

### kinetic-system - Kinetic system evolver {#cmd-kinetic-system}

`kinetic-system` _reaction-file_{:title="Path of a file (or a directory)"} _parameters_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/dump=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"} `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _reaction-file_{:title="Path of a file (or a directory)"}: 
  * _parameters_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}: 
  * `/dump=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: 
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration
  * `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a last column will contain the number of function evaluation for each step

{::comment} synopsis-end: kinetic-system {:/}

{::comment} synopsis-start: ode {:/}

### ode - ODE solver {#cmd-ode}

`ode` _file_{:title="Path of a file (or a directory)"} `/parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/step-size=`_number_{:title="A floating-point number"} `/prec-relative=`_number_{:title="A floating-point number"} `/prec-absolute=`_number_{:title="A floating-point number"} `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}

  * _file_{:title="Path of a file (or a directory)"}: File containing the system
  * `/parameters=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Values of the extra parameters
  * `/annotate=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, a last column will contain the number of function evaluation for each step
  * `/adaptative=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not to use adaptative stepper
  * `/step-size=`_number_{:title="A floating-point number"}: Initial step size for the stepper
  * `/prec-relative=`_number_{:title="A floating-point number"}: Relative precision required
  * `/prec-absolute=`_number_{:title="A floating-point number"}: Absolute precision required
  * `/stepper=`_choice_{:title="One of: bsimp, msadams, msbdf, rk1imp, rk2, rk2imp, rk4, rk4imp, rk8pd, rkck, rkf45"}: Algorithm used for integration

{::comment} synopsis-end: ode {:/}


# Scripting facilities {#scripting}

QSoas provides facilities for scripting, ie running commands
unattended, for instance for preparing series of data files for
fitting or further use. There are a few commands useful only in this
context, such as the following


## Scripting commands

{::comment} synopsis-start: run {:/}

### run - Run commands {#cmd-run}

`run` _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"} `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

Alias: `@`

  * _file..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: First is the command files, following are arguments
  * `/silent=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether or not display is updated during the load
  * `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the commands run are added to the history (defaults to false)

{::comment} synopsis-end: run {:/}
{::comment} description-start: run {:/}
Run commands saved in a file. Commands don't have to have full
arguments provided, as prompting will still be performed in case of
missing arguments.

All the arguments after the first are arguments for the scripts. They
are passed as "special variables" `${1}`, and `${2}`...

Imagine you are often doing the same processing a given type of data
files, say, simply filtering them. You just have to write a script
`process.cmd` containing:

~~~~
load ${1}
auto-filter-fft 
~~~~

And run it this way:

~~~~
QSoas> @ process.cmd data_file.dat
~~~~

If you start to use `run` regularly, you may be interested in the
other scripting commands, such as [`run-for-each`](#cmd-run-for-each),
[`run-for-datasets`](#cmd-run-for-datasets) and
[`startup-files`](#cmd-startup-files)

{::comment} description-end: run {:/}


{::comment} synopsis-start: startup-files {:/}

### startup-files - Startup files {#cmd-startup-files}

`startup-files` `/add=`_file_{:title="Path of a file (or a directory)"} `/rm=`_integer_{:title="An integer"} `/run=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * `/add=`_file_{:title="Path of a file (or a directory)"} (default): Adds the given startup file
  * `/rm=`_integer_{:title="An integer"}: Removes the numbered file
  * `/run=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: If on, runs all the startup files right now

{::comment} synopsis-end: startup-files {:/}
{::comment} description-start: startup-files {:/}
Using this command, you can instruct `QSoas` to execute command files
at startup. Without options, this command displays the list of command
files that `QSoas` will read at the next startup.

Files given to the `/add` options are added at the end of the list.

You remove files from this list by supplying their __number__ (as
given by `startup-files` without options) to the `/rm` option.

Finally, you can re-run all startup files by running:

~~~
QSoas> startup-files /run=true
~~~

{::comment} description-end: startup-files {:/}
{::comment} synopsis-start: run-for-each {:/}

### run-for-each - Loop run a script {#cmd-run-for-each}

`run-for-each` _script_{:title="Path of a file (or a directory)"} _arguments..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."} `/arg2=`_file_{:title="Path of a file (or a directory)"} `/arg3=`_file_{:title="Path of a file (or a directory)"} `/arg4=`_file_{:title="Path of a file (or a directory)"} `/arg5=`_file_{:title="Path of a file (or a directory)"} `/arg6=`_file_{:title="Path of a file (or a directory)"} `/range-type=`_choice_{:title="One of: lin, log"} `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}

  * _script_{:title="Path of a file (or a directory)"}: The script file
  * _arguments..._{:title="One or more files. Can include wildcards such as *, [0-4], etc..."}: All the arguments for the script file to loop on
  * `/arg2=`_file_{:title="Path of a file (or a directory)"}: Second argument to the script
  * `/arg3=`_file_{:title="Path of a file (or a directory)"}: Third argument to the script
  * `/arg4=`_file_{:title="Path of a file (or a directory)"}: Fourth argument to the script
  * `/arg5=`_file_{:title="Path of a file (or a directory)"}: Fifth argument to the script
  * `/arg6=`_file_{:title="Path of a file (or a directory)"}: Sixth argument to the script
  * `/range-type=`_choice_{:title="One of: lin, log"}: If one, transform arguments into ranged numbers
  * `/add-to-history=`_yes-no_{:title="A boolean: yes, on, true or no, off, false"}: Whether the commands run are added to the history (defaults to false)

{::comment} synopsis-end: run-for-each {:/}
{::comment} description-start: run-for-each {:/}
Runs the given script file successively for each argument given. For
instance, running:

~~~
QSoas> run-for-each process-my-file.cmds file1 file2 file3
~~~

Is equivalent to running successively

~~~
QSoas> @ process-my-file.cmds file1 
QSoas> @ process-my-file.cmds file2
QSoas> @ process-my-file.cmds file3
~~~

The arguments don't actually have to be file names, although automatic
completion will only complete file names. If the script you want to
run requires more than one argument, you can specify them (for all the
runs) using the options `/arg2`, `/arg3` and so on:

~~~
QSoas> run-for-each process-my-file.cmds /arg2=other file1 file2 
~~~

Is equivalent to running:

~~~
QSoas> @ process-my-file.cmds file1 other
QSoas> @ process-my-file.cmds file2 other
~~~

{::comment} description-end: run-for-each {:/}
{::comment} synopsis-start: run-for-datasets {:/}

### run-for-datasets - Loop run a script {#cmd-run-for-datasets}

`run-for-datasets` _script_{:title="Path of a file (or a directory)"} _datasets..._{:title="Comma-separated lists of datasets in the stack"}

  * _script_{:title="Path of a file (or a directory)"}: The script file
  * _datasets..._{:title="Comma-separated lists of datasets in the stack"}: All the arguments for the script file to loop on

{::comment} synopsis-end: run-for-datasets {:/}
{::comment} description-start: run-for-datasets {:/}
Runs the given script file for each of the datasets given. Before each
invocation of the script, the dataset is pushed back to the top of the
stack, as if by [`fetch`](#cmd-fetch).
{::comment} description-end: run-for-datasets {:/}
{::comment} synopsis-start: noop {:/}

### noop - No op {#cmd-noop}

`noop` _ignored..._ `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"}

  * _ignored..._: Ignored arguments
  * `/*=`_text_{:title="Arbitrary text. If you need spaces, do not forget to quote them with ', for instance"} (default): Ignored options

{::comment} synopsis-end: noop {:/}
{::comment} description-start: noop {:/}
Does not do anything, but slurps all arguments and options given.
{::comment} description-end: noop {:/}


## Non-interactive commands {#non-interactive}

In addition to purely scripting commands, many commands do not require
user interaction, provided all their arguments are given. They are
listed here:

{::comment} non-interactive-start {:/}

 * [`1`](#cmd-1)
 * [`2`](#cmd-2)
 * [`apply-formula`](#cmd-apply-formula)
 * [`auto-correlation`](#cmd-auto-correlation)
 * [`auto-filter-bs`](#cmd-auto-filter-bs)
 * [`auto-filter-fft`](#cmd-auto-filter-fft)
 * [`average`](#cmd-average)
 * [`bin`](#cmd-bin)
 * [`break`](#cmd-break)
 * [`browse`](#cmd-browse)
 * [`cat`](#cmd-cat)
 * [`cd`](#cmd-cd)
 * [`chop`](#cmd-chop)
 * [`clear`](#cmd-clear)
 * [`clear-stack`](#cmd-clear-stack)
 * [`combine-fits`](#cmd-combine-fits)
 * [`commands`](#cmd-commands)
 * [`comment`](#cmd-comment)
 * [`contract`](#cmd-contract)
 * [`credits`](#cmd-credits)
 * [`custom-fit`](#cmd-custom-fit)
 * [`dataset-options`](#cmd-dataset-options)
 * [`define-alias`](#cmd-define-alias)
 * [`define-derived-fit`](#cmd-define-derived-fit)
 * [`define-lw-fit`](#cmd-define-lw-fit)
 * [`diff`](#cmd-diff)
 * [`diff2`](#cmd-diff2)
 * [`display-aliases`](#cmd-display-aliases)
 * [`div`](#cmd-div)
 * [`downsample`](#cmd-downsample)
 * [`drop`](#cmd-drop)
 * [`dx`](#cmd-dx)
 * [`dy`](#cmd-dy)
 * [`echem-peaks`](#cmd-echem-peaks)
 * [`edit`](#cmd-edit)
 * [`eval`](#cmd-eval)
 * [`expand`](#cmd-expand)
 * [`fetch`](#cmd-fetch)
 * [`find-peaks`](#cmd-find-peaks)
 * [`find-root`](#cmd-find-root)
 * [`find-steps`](#cmd-find-steps)
 * [`flag`](#cmd-flag)
 * [`generate-buffer`](#cmd-generate-buffer)
 * [`graphics-settings`](#cmd-graphics-settings)
 * [`help`](#cmd-help)
 * [`integrate`](#cmd-integrate)
 * [`kinetic-system`](#cmd-kinetic-system)
 * [`linear-kinetic-system`](#cmd-linear-kinetic-system)
 * [`load`](#cmd-load)
 * [`load-as-csv`](#cmd-load-as-csv)
 * [`load-as-text`](#cmd-load-as-text)
 * [`load-documentation`](#cmd-load-documentation)
 * [`load-fits`](#cmd-load-fits)
 * [`load-stack`](#cmd-load-stack)
 * [`merge`](#cmd-merge)
 * [`noop`](#cmd-noop)
 * [`norm`](#cmd-norm)
 * [`ode`](#cmd-ode)
 * [`output`](#cmd-output)
 * [`overlay`](#cmd-overlay)
 * [`overlay-buffer`](#cmd-overlay-buffer)
 * [`points`](#cmd-points)
 * [`print`](#cmd-print)
 * [`pwd`](#cmd-pwd)
 * [`quit`](#cmd-quit)
 * [`redo`](#cmd-redo)
 * [`remove-spikes`](#cmd-remove-spikes)
 * [`rename`](#cmd-rename)
 * [`ruby-run`](#cmd-ruby-run)
 * [`run`](#cmd-run)
 * [`run-for-datasets`](#cmd-run-for-datasets)
 * [`run-for-each`](#cmd-run-for-each)
 * [`save`](#cmd-save)
 * [`save-buffers`](#cmd-save-buffers)
 * [`save-history`](#cmd-save-history)
 * [`save-output`](#cmd-save-output)
 * [`save-stack`](#cmd-save-stack)
 * [`segments-chop`](#cmd-segments-chop)
 * [`shiftx`](#cmd-shiftx)
 * [`show-stack`](#cmd-show-stack)
 * [`sim-ecr-wave`](#cmd-sim-ecr-wave)
 * [`sim-eec-transport`](#cmd-sim-eec-transport)
 * [`sim-eecr-relay-wave`](#cmd-sim-eecr-relay-wave)
 * [`sim-eecr-wave`](#cmd-sim-eecr-wave)
 * [`sim-exponential-decay`](#cmd-sim-exponential-decay)
 * [`sim-fefe-hp-inact`](#cmd-sim-fefe-hp-inact)
 * [`sim-inact-react-amplitude-2phases`](#cmd-sim-inact-react-amplitude-2phases)
 * [`sim-kinetic-system`](#cmd-sim-kinetic-system)
 * [`sim-linear-kinetic-system`](#cmd-sim-linear-kinetic-system)
 * [`sim-lw`](#cmd-sim-lw)
 * [`sim-multiexp-multistep`](#cmd-sim-multiexp-multistep)
 * [`sim-nernst`](#cmd-sim-nernst)
 * [`sim-react-exp`](#cmd-sim-react-exp)
 * [`sim-slow-scan-hp`](#cmd-sim-slow-scan-hp)
 * [`sim-slow-scan-lp`](#cmd-sim-slow-scan-lp)
 * [`sort`](#cmd-sort)
 * [`split-monotonic`](#cmd-split-monotonic)
 * [`splita`](#cmd-splita)
 * [`splitb`](#cmd-splitb)
 * [`startup-files`](#cmd-startup-files)
 * [`stats`](#cmd-stats)
 * [`strip-if`](#cmd-strip-if)
 * [`subtract`](#cmd-subtract)
 * [`sv-decomp`](#cmd-sv-decomp)
 * [`temperature`](#cmd-temperature)
 * [`test-lw`](#cmd-test-lw)
 * [`tex-commands`](#cmd-tex-commands)
 * [`transpose`](#cmd-transpose)
 * [`undo`](#cmd-undo)
 * [`unflag`](#cmd-unflag)
 * [`unwrap`](#cmd-unwrap)
 * [`update-documentation`](#cmd-update-documentation)
 * [`zero`](#cmd-zero)
{::comment} non-interacive-end {:/}


## Ruby code {#ruby}

QSoas internally uses [Ruby][ruby] for the interpretation of all
formulas. This means in particular that all formulas must be valid
ruby code.

Basically, the [Ruby][ruby] syntax ressembles that of other symbolic
evaluation programs (it is quite close to the one from
[gnuplot][gnuplot]), with the following restrictions: 

 * never use a name starting with an uppercase for parameters, as
   those have a special meaning to the Ruby interpreter
 * don't abbreviate floating points: `2.` and `.4` are invalid, use
   `2.0` and `0.4` instead
 * case matters: `Pi` is $$\pi$$, while `pi` is nothing defined.

In addition to standard mathematical functions from the [Math][math]
module, the following special functions are available:

{::comment} special-functions-start {:/}

 * `atanc`: $$\frac{\tan^{-1} x}{x}$$
 * `atanhc`: $$\frac{\tanh^{-1} x}{x}$$
 * `bessel_j0`: Regular cylindrical Bessel function of 0th order, $$J_0(x)$$
 * `bessel_j1`: Regular cylindrical Bessel function of first order, $$J_1(x)$$
 * `bessel_jn`: Regular cylindrical Bessel function of n-th order, $$J_n(x)$$
 * `expint_e1`: Exponential integral $$E_1(x) = \int_{x}^{\infty} \frac{\exp -t}{t} \mathrm{d} t$$
 * `expint_e2`: Exponential integral $$E_2(x) = \int_{x}^{\infty} \frac{\exp -t}{t^2} \mathrm{d} t$$
 * `expint_en`: Exponential integral $$E_n(x) = \int_{x}^{\infty} \frac{\exp -t}{t^n} \mathrm{d} t$$

{::comment} special-functions-end {:/}

Similarly, some physical/mathematical constants are available. Please
keep in mind again that they necessarily start with an **uppercase**
letter.

{::comment} constants-start {:/}

 * `F`: Faraday's constant, $$F$$ -- 96485.3
 * `Pi`, `PI`: $$\pi$$ -- 3.14159
 * `R`: Molar gas constant, $$R$$ -- 8.31447

{::comment} constants-end {:/}


[ruby]:http://www.ruby-lang.org/ "Ruby, the programming language"
[math]:http://www.ruby-doc.org/core-1.9.3/Math.html "Documentation of the Math module"
[gnuplot]:http://www.gnuplot.info/ "Gnuplot, the plotting program"

